{
  if (qName.equals("rule")) {
    id=attrs.getValue("id");
    name=attrs.getValue("name");
    if (inRuleGroup && id == null) {
      id=ruleGroupId;
    }
    if (inRuleGroup && name == null) {
      name=ruleGroupName;
    }
  }
 else   if (qName.equals("rules")) {
    language=Language.getLanguageForShortName(attrs.getValue("lang"));
  }
 else   if (qName.equals(PATTERN)) {
    inPattern=true;
    if (attrs.getValue(MARK) != null && (attrs.getValue(MARK_FROM) != null)) {
      throw new SAXException("You cannot use both mark and mark_from attributes." + "\n Line: " + dLocator.getLineNumber() + ", column: "+ dLocator.getColumnNumber()+ ".");
    }
    if (attrs.getValue(MARK) != null && (attrs.getValue(MARK_TO) != null)) {
      throw new SAXException("You cannot use both mark and mark_to attributes." + "\n Line: " + dLocator.getLineNumber() + ", column: "+ dLocator.getColumnNumber()+ ".");
    }
    if (attrs.getValue(MARK) != null) {
      positionCorrection=Integer.parseInt(attrs.getValue(MARK));
    }
    if (attrs.getValue(MARK_FROM) != null) {
      positionCorrection=Integer.parseInt(attrs.getValue(MARK_FROM));
    }
    if (attrs.getValue(MARK_TO) != null) {
      endPositionCorrection=Integer.parseInt(attrs.getValue(MARK_TO));
      if (endPositionCorrection > 0) {
        throw new SAXException("End position correction (mark_to=" + endPositionCorrection + ") cannot be larger than 0: "+ "\n Line: "+ dLocator.getLineNumber()+ ", column: "+ dLocator.getColumnNumber()+ ".");
      }
      singleTokenCorrection=false;
    }
 else {
      singleTokenCorrection=true;
    }
    if (attrs.getValue(CASE_SENSITIVE) != null && YES.equals(attrs.getValue(CASE_SENSITIVE))) {
      caseSensitive=true;
    }
  }
 else   if (qName.equals(EXCEPTION)) {
    inException=true;
    exceptions=new StringBuilder();
    if (attrs.getValue(NEGATE) != null) {
      exceptionStringNegation=attrs.getValue(NEGATE).equals(YES);
    }
    if (attrs.getValue(SCOPE) != null) {
      exceptionValidNext=attrs.getValue(SCOPE).equals("next");
      exceptionValidPrev=attrs.getValue(SCOPE).equals("previous");
    }
    if (attrs.getValue(INFLECTED) != null) {
      exceptionStringInflected=attrs.getValue(INFLECTED).equals(YES);
    }
    if (attrs.getValue(POSTAG) != null) {
      exceptionPosToken=attrs.getValue(POSTAG);
      if (attrs.getValue(POSTAG_REGEXP) != null) {
        exceptionPosRegExp=attrs.getValue(POSTAG_REGEXP).equals(YES);
      }
      if (attrs.getValue(NEGATE_POS) != null) {
        exceptionPosNegation=attrs.getValue(NEGATE_POS).equals(YES);
      }
    }
    if (attrs.getValue(REGEXP) != null) {
      exceptionStringRegExp=attrs.getValue(REGEXP).equals(YES);
    }
    if (attrs.getValue(SPACEBEFORE) != null) {
      exceptionSpaceBefore=YES.equals(attrs.getValue(SPACEBEFORE));
      exceptionSpaceBeforeSet=IGNORE.equals(attrs.getValue(SPACEBEFORE)) ^ true;
    }
  }
 else   if (qName.equals(AND)) {
    inAndGroup=true;
  }
 else   if (qName.equals(UNIFY)) {
    inUnification=true;
    uFeature=attrs.getValue(FEATURE);
    if (attrs.getValue(TYPE) != null) {
      uType=attrs.getValue(TYPE);
    }
 else {
      uType="";
    }
    if (attrs.getValue(NEGATE) != null && YES.equals(attrs.getValue(NEGATE))) {
      uniNegation=true;
    }
    uniCounter=0;
  }
 else   if (qName.equals(TOKEN)) {
    inToken=true;
    if (attrs.getValue(NEGATE) != null) {
      tokenNegated=attrs.getValue(NEGATE).equals(YES);
    }
    if (attrs.getValue(INFLECTED) != null) {
      tokenInflected=attrs.getValue(INFLECTED).equals(YES);
    }
    if (attrs.getValue(SKIP) != null) {
      skipPos=Integer.parseInt(attrs.getValue(SKIP));
    }
    elements=new StringBuilder();
    if (attrs.getValue(POSTAG) != null) {
      posToken=attrs.getValue(POSTAG);
      if (attrs.getValue(POSTAG_REGEXP) != null) {
        posRegExp=attrs.getValue(POSTAG_REGEXP).equals(YES);
      }
      if (attrs.getValue(NEGATE_POS) != null) {
        posNegation=attrs.getValue(NEGATE_POS).equals(YES);
      }
    }
    if (attrs.getValue(REGEXP) != null) {
      stringRegExp=attrs.getValue(REGEXP).equals(YES);
    }
    if (attrs.getValue(SPACEBEFORE) != null) {
      tokenSpaceBefore=YES.equals(attrs.getValue(SPACEBEFORE));
      tokenSpaceBeforeSet=IGNORE.equals(attrs.getValue(SPACEBEFORE)) ^ true;
    }
    if (!inAndGroup) {
      tokenCounter++;
    }
  }
 else   if (qName.equals(DISAMBIG)) {
    inDisamb=true;
    disambiguatedPOS=attrs.getValue(POSTAG);
    if (attrs.getValue(ACTION) != null) {
      disambigAction=DisambiguationPatternRule.DisambiguatorAction.toAction(attrs.getValue(ACTION).toUpperCase());
    }
 else {
      disambigAction=DisambiguationPatternRule.DisambiguatorAction.toAction("REPLACE");
    }
    disamb=new StringBuilder();
  }
 else   if (qName.equals(MATCH)) {
    inMatch=true;
    match=new StringBuilder();
    Match.CaseConversion caseConv=Match.CaseConversion.NONE;
    if (attrs.getValue("case_conversion") != null) {
      caseConv=Match.CaseConversion.toCase(attrs.getValue("case_conversion").toUpperCase());
    }
    Match.IncludeRange includeRange=Match.IncludeRange.NONE;
    if (attrs.getValue("include_skipped") != null) {
      includeRange=Match.IncludeRange.toRange(attrs.getValue("include_skipped").toUpperCase());
    }
    final Match mWorker=new Match(attrs.getValue(POSTAG),attrs.getValue("postag_replace"),YES.equals(attrs.getValue(POSTAG_REGEXP)),attrs.getValue("regexp_match"),attrs.getValue("regexp_replace"),caseConv,YES.equals(attrs.getValue("setpos")),includeRange);
    if (inDisamb) {
      if (attrs.getValue(NO) != null) {
        final int refNumber=Integer.parseInt(attrs.getValue(NO));
        if (refNumber > elementList.size()) {
          throw new SAXException("Only backward references in match elements are possible, tried to specify token " + refNumber + "\n Line: "+ dLocator.getLineNumber()+ ", column: "+ dLocator.getColumnNumber()+ ".");
        }
        mWorker.setTokenRef(refNumber);
        posSelector=mWorker;
      }
    }
 else     if (inToken) {
      if (attrs.getValue(NO) != null) {
        final int refNumber=Integer.parseInt(attrs.getValue(NO));
        if (refNumber > elementList.size()) {
          throw new SAXException("Only backward references in match elements are possible, tried to specify token " + refNumber + "\n Line: "+ dLocator.getLineNumber()+ ", column: "+ dLocator.getColumnNumber()+ ".");
        }
        mWorker.setTokenRef(refNumber);
        tokenReference=mWorker;
        elements.append("\\" + refNumber);
      }
    }
  }
 else   if (qName.equals(RULEGROUP)) {
    ruleGroupId=attrs.getValue("id");
    ruleGroupName=attrs.getValue("name");
    inRuleGroup=true;
  }
 else   if (qName.equals(UNIFICATION)) {
    uFeature=attrs.getValue(FEATURE);
    inUnificationDef=true;
  }
 else   if (qName.equals("equivalence")) {
    uType=attrs.getValue(TYPE);
  }
 else   if (qName.equals(WD)) {
    wdLemma=attrs.getValue("lemma");
    wdPos=attrs.getValue("pos");
    inWord=true;
    wd=new StringBuilder();
  }
 else   if (qName.equals("example")) {
    inExample=true;
    if (untouchedExamples == null) {
      untouchedExamples=new ArrayList<String>();
    }
    if (disambExamples == null) {
      disambExamples=new ArrayList<DisambiguatedExample>();
    }
    untouched=attrs.getValue("type").equals("untouched");
    if (attrs.getValue("type").equals("ambiguous")) {
      input=attrs.getValue("inputform");
      output=attrs.getValue("outputform");
    }
    example=new StringBuilder();
  }
 else   if (qName.equals("marker")) {
    example.append("<marker>");
  }
}
