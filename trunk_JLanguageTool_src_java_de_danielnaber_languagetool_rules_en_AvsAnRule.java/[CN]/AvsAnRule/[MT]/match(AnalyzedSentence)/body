{
  final List<RuleMatch> ruleMatches=new ArrayList<RuleMatch>();
  final AnalyzedTokenReadings[] tokens=text.getTokensWithoutWhitespace();
  String prevToken="";
  for (int i=1; i < tokens.length; i++) {
    String token=tokens[i].getToken();
    boolean doesRequireA=false;
    boolean doesRequireAn=false;
    boolean isException=false;
    final String[] parts=token.split("[-']");
    if (parts.length >= 1 && !parts[0].equalsIgnoreCase("a")) {
      token=parts[0];
    }
    token=token.replaceAll("&quot|&amp|&lt|&gt|[^a-zA-Z0-9\\.']","");
    if (StringTools.isEmpty(token)) {
      continue;
    }
    final char tokenFirstChar=token.charAt(0);
    if (requiresA.contains(token.toLowerCase()) || requiresA.contains(token)) {
      isException=true;
      doesRequireA=true;
    }
    if (requiresAn.contains(token.toLowerCase()) || requiresAn.contains(token)) {
      if (isException) {
        throw new IllegalStateException(token + " is listed in both det_a.txt and det_an.txt");
      }
      isException=true;
      doesRequireAn=true;
    }
    if (!isException) {
      if (StringTools.isAllUppercase(token)) {
        doesRequireAn=false;
        doesRequireA=false;
      }
 else       if (isVowel(tokenFirstChar)) {
        doesRequireAn=true;
      }
 else {
        doesRequireA=true;
      }
    }
    String msg=null;
    if (prevToken.equalsIgnoreCase("a") && doesRequireAn) {
      String repl="an";
      if (prevToken.equals("A")) {
        repl="An";
      }
      msg="Use <suggestion>" + repl + "</suggestion> instead of '"+ prevToken+ "' if the following "+ "word starts with a vowel sound, e.g. 'an article', "+ "'an hour'";
    }
 else     if (prevToken.equalsIgnoreCase("an") && doesRequireA) {
      String repl="a";
      if (prevToken.equals("An")) {
        repl="A";
      }
      msg="Use <suggestion>" + repl + "</suggestion> instead of '"+ prevToken+ "' if the following "+ "word doesn't start with a vowel sound, e.g. 'a sentence', "+ "'a university'";
    }
    if (msg != null) {
      final int prevPos=tokens[i - 1].getStartPos();
      final RuleMatch ruleMatch=new RuleMatch(this,prevPos,prevPos + prevToken.length(),msg,"Wrong article");
      ruleMatches.add(ruleMatch);
    }
    if (tokens[i].hasPosTag("DT")) {
      prevToken=token;
    }
 else {
      prevToken="";
    }
  }
  return toRuleMatchArray(ruleMatches);
}
