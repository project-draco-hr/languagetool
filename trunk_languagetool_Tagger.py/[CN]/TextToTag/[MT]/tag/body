def tag(self, data_table, seqs_table):
    'Tag self.text and return list of tuples\n\t\t(word, normalized word, most probable tag)'
    self.text = self.expandEntities(self.text)
    result_tuple_list = []
    count_wrong_tags = 'n/a'
    is_bnc = 0
    word_matches = self.getBNCTuples(self.text)
    if (len(word_matches) > 0):
        is_bnc = 1
        print  >> sys.stderr, 'BNC text detected.'
        count_wrong_tags = 0
    else:
        word_matches = self.nonword.split(self.text)
    if (not is_bnc):
        j = (len(word_matches) - 1)
        while (j >= 0):
            w = word_matches[j]
            s_end_match = self.sentence_end.search(w)
            if s_end_match:
                word_matches[j] = w[:(len(w) - len(s_end_match.group(1)))]
                word_matches.insert((j + 1), s_end_match.group(1))
                break
            j = (j - 1)
    i = 0
    tagged_list = [self.DUMMY, self.DUMMY]
    tagged_list_bnc = [self.DUMMY, self.DUMMY]
    while (i < len(word_matches)):
        next_token = None
        tags = None
        if is_bnc:
            (tag, word) = word_matches[i]
            if ((i + 1) < len(word_matches)):
                (next_token, foo) = word_matches[(i + 1)]
            word = self.normalise(word)
            tags = self.splitBNCTag(tag)
        else:
            word = word_matches[i]
            if ((i + 1) < len(word_matches)):
                next_token = word_matches[(i + 1)]
        if ((i + 2) < len(word_matches)):
            tuple_word = ('%s %s' % (word, word_matches[(i + 2)]))
            if data_table.has_key(tuple_word):
                word = tuple_word
                i = (i + 2)
        r = Text.tagWord(self, word, data_table)
        tagged_list.extend(r)
        if is_bnc:
            for el in r:
                tagged_list_bnc.append((el[0], tags))
        i = (i + 1)
    tagged_list.append(self.DUMMY)
    tagged_list.append(self.DUMMY)
    i = 0
    tag_table = {}
    for tagged in tagged_list:
        if (i == 0):
            i = (i + 1)
            continue
        next = [(None, 1)]
        (orig_word, tagged_word, tag_tuples) = self.getTuple(tagged)
        if ((not tagged_word) and (not (tagged == None))):
            i = (i + 1)
            result_tuple_list.append((orig_word, tagged_word, None))
            continue
        if (not tag_tuples):
            tag_tuples = [(None, 1)]
        (prev_word, prev) = self.getPrevToken(i, tagged_list)
        if (not prev):
            prev = [(None, 1)]
        (next_word, next) = self.getNextToken(i, tagged_list)
        if (not next):
            next = [(None, 1)]
        self.applyConstraints(prev_word, orig_word, next_word, tag_tuples)
        best_tag = self.getBestTag(prev, tag_tuples, next, seqs_table, i, tag_table)
        if tagged:
            result_tuple_list.append((orig_word, tagged_word, best_tag))
        if is_bnc:
            wrong_tags = self.checkBNCMatch(i, tagged_list_bnc, orig_word, best_tag)
            count_wrong_tags = (count_wrong_tags + wrong_tags)
        i = (i + 1)
    i = 0
    for tag_triple in result_tuple_list:
        triple = self.applyTagRules(tag_triple[0], tag_triple[1], tag_triple[2])
        if triple:
            result_tuple_list[i] = triple
        if self.sentence_end.search(tag_triple[0]):
            result_tuple_list[i] = (tag_triple[0], None, None)
        i = (i + 1)
    stat = self.getStats(count_wrong_tags)
    print  >> sys.stderr, stat
    return result_tuple_list
