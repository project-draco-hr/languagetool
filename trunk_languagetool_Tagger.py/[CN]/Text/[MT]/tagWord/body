def tagWord(self, word, data_table):
    'Find all possible tags for a word and return a list of tuples:\n\t\t[(orig_word, normalised_word, [(tag, probability])]'
    orig_word = word
    word = self.normalise(word)
    if (word and self.nonword_punct.match(word)):
        return [(orig_word, orig_word, [])]
    if ((not word) or self.nonword.match(word)):
        return [(orig_word, None, [])]
    if (word.count("'") > 1):
        print  >> sys.stderr, ("*** What's this, more than one apostroph: '%s'?" % word)
    special_cases = ("n't", "'s", "'re", "'ll", "'ve")
    for special_case in special_cases:
        special_case_pos = word.find(special_case)
        if ((special_case_pos != (-1)) and (special_case_pos != 0)):
            first_part = self.tagWord(word[0:special_case_pos], data_table)[0]
            second_part = self.tagWord(special_case, data_table)[0]
            tag_results = []
            tag_results.append((word[0:special_case_pos], first_part[1], first_part[2]))
            tag_results.append((special_case, second_part[1], second_part[2]))
            return tag_results
    if (not data_table.has_key(word)):
        self.count_unknown = (self.count_unknown + 1)
        guess_tag = self.guessTag(word)
        if guess_tag:
            return [(orig_word, word, [(guess_tag, 1)])]
        else:
            return [(orig_word, word, [('unknown', 1)])]
    else:
        pos_table = data_table[word].table
        if (len(pos_table) == 1):
            self.count_unambiguous = (self.count_unambiguous + 1)
            return [(orig_word, word, [(pos_table.keys()[0], 1)])]
        else:
            tag_tuples = []
            for pos_tag in pos_table.keys():
                tag_tuples.append((pos_tag, pos_table[pos_tag]))
            self.count_ambiguous = (self.count_ambiguous + 1)
            return [(orig_word, word, tag_tuples)]
