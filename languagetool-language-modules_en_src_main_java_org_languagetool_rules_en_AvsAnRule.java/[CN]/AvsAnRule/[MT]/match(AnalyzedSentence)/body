{
  final List<RuleMatch> ruleMatches=new ArrayList<>();
  final AnalyzedTokenReadings[] tokens=sentence.getTokensWithoutWhitespace();
  String prevToken="";
  int prevPos=0;
  for (int i=1; i < tokens.length; i++) {
    String token=tokens[i].getToken();
    boolean doesRequireA=false;
    boolean doesRequireAn=false;
    boolean isException=false;
    final String[] parts=token.split("[-']");
    if (parts.length >= 1 && !parts[0].equalsIgnoreCase("a")) {
      token=parts[0];
    }
    if (tokens[i].isWhitespaceBefore() || !"-".equals(token)) {
      token=token.replaceAll("[^??a-zA-Z0-9\\.;,:']","");
      if (StringTools.isEmpty(token)) {
        continue;
      }
    }
    final char tokenFirstChar=token.charAt(0);
    if (getWordsRequiringA().contains(token.toLowerCase()) || getWordsRequiringA().contains(token)) {
      isException=true;
      doesRequireA=true;
    }
    if (getWordsRequiringAn().contains(token.toLowerCase()) || getWordsRequiringAn().contains(token)) {
      if (isException) {
        isException=true;
        doesRequireA=false;
        doesRequireAn=false;
      }
 else {
        isException=true;
        doesRequireAn=true;
      }
    }
    if (!isException) {
      if (StringTools.isAllUppercase(token) || StringTools.isMixedCase(token)) {
        doesRequireAn=false;
        doesRequireA=false;
      }
 else       if (isVowel(tokenFirstChar)) {
        doesRequireAn=true;
      }
 else {
        doesRequireA=true;
      }
    }
    RuleMatch match=getRuleMatch(prevToken,prevPos,doesRequireA,doesRequireAn);
    if (match != null) {
      ruleMatches.add(match);
    }
    if (tokens[i].hasPosTag("DT")) {
      prevToken=token;
      prevPos=tokens[i].getStartPos();
    }
 else {
      prevToken="";
    }
  }
  return toRuleMatchArray(ruleMatches);
}
