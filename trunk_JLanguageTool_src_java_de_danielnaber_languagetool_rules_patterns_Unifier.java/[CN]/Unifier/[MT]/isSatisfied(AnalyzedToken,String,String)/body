{
  if (allFeatsIn && equivalencesMatched.isEmpty()) {
    return false;
  }
  if (StringTools.isEmpty(feature)) {
    return false;
  }
  boolean unified=true;
  final String[] features=StringTools.trimWhitespace(feature).split(FEATURE_SEPARATOR);
  String[] types;
  if (!allFeatsIn) {
    tokCnt++;
    while (equivalencesMatched.size() <= tokCnt) {
      equivalencesMatched.add(new HashMap<String,Set<String>>());
    }
    for (    final String feat : features) {
      if (StringTools.isEmpty(type)) {
        types=equivalenceFeatures.get(feat).toArray(new String[equivalenceFeatures.get(feat).size()]);
      }
 else {
        types=type.split(FEATURE_SEPARATOR);
      }
      for (      final String typename : types) {
        final Element testElem=equivalenceTypes.get(feat + FEATURE_TYPE_SEPARATOR + typename);
        if (testElem == null) {
          return false;
        }
        if (testElem.isMatched(aToken)) {
          if (!equivalencesMatched.get(tokCnt).containsKey(feat)) {
            final Set<String> typeSet=new HashSet<String>();
            typeSet.add(typename);
            equivalencesMatched.get(tokCnt).put(feat,typeSet);
          }
 else {
            equivalencesMatched.get(tokCnt).get(feat).add(typename);
          }
        }
      }
      unified&=equivalencesMatched.get(tokCnt).containsKey(feat);
      if (!unified) {
        break;
      }
    }
    if (unified) {
      if (tokCnt == 0 || tokSequence.isEmpty()) {
        tokSequence.add(new AnalyzedTokenReadings(aToken));
      }
 else {
        tokSequence.get(0).addReading(aToken);
      }
    }
  }
 else {
    unified&=checkNext(aToken,features,type);
  }
  return unified ^ negation;
}
