{
  boolean unifiedNext=true;
  boolean anyFeatUnified=false;
  String[] types;
  if (allFeatsIn) {
    for (int i=0; i <= tokCnt; i++) {
      boolean allFeatsUnified=true;
      for (      String feat : features) {
        boolean featUnified=false;
        if (StringTools.isEmpty(type)) {
          types=equivalenceFeatures.get(feat).toArray(new String[equivalenceFeatures.get(feat).size()]);
        }
 else {
          types=type.split(",");
        }
        for (        String typename : types) {
          if (featuresFound.get(i) && equivalencesMatched.get(i).containsKey(feat) && equivalencesMatched.get(i).get(feat).contains(typename)) {
            final Element testElem=equivalenceTypes.get(feat + ":" + typename);
            featUnified=featUnified || testElem.isMatched(AT);
          }
        }
        allFeatsUnified&=featUnified;
      }
      tmpFeaturesFound.set(i,allFeatsUnified);
      anyFeatUnified|=allFeatsUnified;
    }
    unifiedNext&=anyFeatUnified;
    if (unifiedNext) {
      if (tokSequence.size() == readingsCounter) {
        tokSequence.add(new AnalyzedTokenReadings(AT));
      }
 else {
        tokSequence.get(readingsCounter).addReading(AT);
      }
    }
  }
  return unifiedNext;
}
