{
  boolean unifiedNext=true;
  boolean anyFeatUnified=false;
  String[] types;
  ArrayList<Boolean> tokenFeaturesFound=new ArrayList<Boolean>(tmpFeaturesFound);
  if (allFeatsIn) {
    for (int i=0; i <= tokCnt; i++) {
      boolean allFeatsUnified=true;
      for (      final String feat : features) {
        boolean featUnified=false;
        types=getTypes(feat,type);
        for (        final String typename : types) {
          if (featuresFound.get(i) && equivalencesMatched.get(i).containsKey(feat) && equivalencesMatched.get(i).get(feat).contains(typename)) {
            final Element testElem=equivalenceTypes.get(new EquivalenceTypeLocator(feat,typename));
            featUnified=featUnified || testElem.isMatched(aToken);
          }
        }
        allFeatsUnified&=featUnified;
      }
      tokenFeaturesFound.set(i,allFeatsUnified);
      anyFeatUnified|=allFeatsUnified;
    }
    unifiedNext&=anyFeatUnified;
    if (unifiedNext) {
      if (tokSequence.size() == readingsCounter) {
        tokSequence.add(new AnalyzedTokenReadings(aToken,0));
      }
 else {
        tokSequence.get(readingsCounter).addReading(aToken);
      }
      tmpFeaturesFound=tokenFeaturesFound;
    }
  }
  return unifiedNext;
}
