{
  final PatternRule rule=(PatternRule)this.rule;
  final String errMessage=formatMatches(tokens,tokenPositions,firstMatchToken,rule.getMessage(),rule.getSuggestionMatches());
  final String suggestionsOutMsg=formatMatches(tokens,tokenPositions,firstMatchToken,rule.getSuggestionsOutMsg(),rule.getSuggestionMatchesOutMsg());
  int correctedStPos=0;
  if (rule.startPositionCorrection > 0) {
    for (int l=0; l <= rule.startPositionCorrection; l++) {
      correctedStPos+=tokenPositions[l];
    }
    correctedStPos--;
  }
  AnalyzedTokenReadings firstMatchTokenObj=tokens[firstMatchToken + correctedStPos];
  boolean startsWithUppercase=StringTools.startsWithUppercase(firstMatchTokenObj.getToken()) && !matchConvertsCase(rule.getSuggestionMatches()) && !matchConvertsCase(rule.getSuggestionMatchesOutMsg());
  if (firstMatchTokenObj.isSentenceStart() && tokens.length > firstMatchToken + correctedStPos + 1) {
    firstMatchTokenObj=tokens[firstMatchToken + correctedStPos + 1];
    startsWithUppercase=StringTools.startsWithUppercase(firstMatchTokenObj.getToken());
  }
  if (firstMarkerMatchToken == -1) {
    firstMarkerMatchToken=firstMatchToken;
  }
  int fromPos=tokens[firstMarkerMatchToken].getStartPos();
  if (errMessage.contains(SUGGESTION_START_TAG + ",") && firstMarkerMatchToken >= 1) {
    fromPos=tokens[firstMarkerMatchToken - 1].getStartPos() + tokens[firstMarkerMatchToken - 1].getToken().length();
  }
  if (lastMarkerMatchToken == -1) {
    lastMarkerMatchToken=lastMatchToken;
  }
  final AnalyzedTokenReadings token=tokens[Math.min(lastMarkerMatchToken,tokens.length - 1)];
  int toPos=token.getStartPos() + token.getToken().length();
  if (fromPos < toPos) {
    if (!(errMessage.contains("<pleasespellme/>") && errMessage.contains("<mistake/>"))) {
      final String clearMsg=errMessage.replaceAll("<pleasespellme/>","").replaceAll("<mistake/>","");
      return new RuleMatch(rule,fromPos,toPos,clearMsg,rule.getShortMessage(),startsWithUppercase,suggestionsOutMsg);
    }
  }
  return null;
}
