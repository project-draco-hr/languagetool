{
  for (  final DisambiguationPatternRule rule : rules) {
    if (rule.getUntouchedExamples() != null) {
      final List<String> goodSentences=rule.getUntouchedExamples();
      for (      String goodSentence : goodSentences) {
        goodSentence=goodSentence.replaceAll("[\\n\\t]+","");
        goodSentence=cleanXML(goodSentence);
        assertTrue(goodSentence.trim().length() > 0);
        final AnalyzedSentence sent=disambiguateUntil(rules,rule.getId(),languageTool.getRawAnalyzedSentence(goodSentence));
        assertEquals(sent,rule.replace(sent));
      }
    }
    final List<DisambiguatedExample> examples=rule.getExamples();
    if (examples != null) {
      for (      final DisambiguatedExample example : examples) {
        final String outputForms=example.getDisambiguated();
        final int expectedMatchStart=example.getExample().indexOf("<marker>");
        final int expectedMatchEnd=example.getExample().indexOf("</marker>") - "<marker>".length();
        if (expectedMatchStart == -1 || expectedMatchEnd == -1) {
          fail(lang + ": No error position markup ('<marker>...</marker>') in bad example in rule " + rule);
        }
        final String inputForms=example.getAmbiguous();
        assertTrue(inputForms.trim().length() > 0);
        assertNotSame(outputForms,inputForms);
        final AnalyzedSentence sent=disambiguateUntil(rules,rule.getId(),languageTool.getRawAnalyzedSentence(cleanXML(example.getExample())));
        final AnalyzedSentence disambiguatedSent=rule.replace(sent);
        assertNotSame(sent,disambiguatedSent);
        String reading="";
        for (        final AnalyzedTokenReadings readings : sent.getTokens()) {
          if (readings.isSentStart() && inputForms.indexOf("<S>") == -1) {
            continue;
          }
          if (readings.getStartPos() == expectedMatchStart) {
            final AnalyzedTokenReadings r[]={readings};
            reading=new AnalyzedSentence(r).toString();
            assertTrue(readings.getStartPos() == expectedMatchStart && readings.getStartPos() + readings.getToken().length() == expectedMatchEnd);
            break;
          }
        }
        assertTrue("The input form for the rule " + rule.getId() + " in the example: "+ example.toString()+ " is different than expected ("+ reading+ ").",reading.equals(inputForms));
        for (        final AnalyzedTokenReadings readings : disambiguatedSent.getTokens()) {
          if (readings.isSentStart() && outputForms.indexOf("<S>") == -1) {
            continue;
          }
          if (readings.getStartPos() == expectedMatchStart) {
            final AnalyzedTokenReadings r[]={readings};
            reading=new AnalyzedSentence(r).toString();
            assertTrue(readings.getStartPos() == expectedMatchStart && readings.getStartPos() + readings.getToken().length() == expectedMatchEnd);
            break;
          }
        }
        assertTrue("The output form for the rule " + rule.getId() + " in the example: "+ example.toString()+ " is different than expected ("+ reading+ ").",reading.equals(outputForms));
      }
    }
  }
}
