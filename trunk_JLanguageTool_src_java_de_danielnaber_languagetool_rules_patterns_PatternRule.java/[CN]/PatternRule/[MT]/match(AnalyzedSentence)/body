{
  final List<RuleMatch> ruleMatches=new ArrayList<RuleMatch>();
  final AnalyzedTokenReadings[] tokens=text.getTokensWithoutWhitespace();
  final int[] tokenPositions=new int[tokens.length + 1];
  int tokenPos=0;
  int prevSkipNext=0;
  int skipNext=0;
  int matchPos=0;
  int skipShift=0;
  int skipShiftTotal=0;
  int firstMatchToken=-1;
  int lastMatchToken=-1;
  final int patternSize=patternElements.size();
  Element elem=null, prevElement=null;
  final boolean startWithSentStart=patternElements.get(0).isSentStart();
  for (int i=0; i < tokens.length; i++) {
    boolean allElementsMatch=true;
    if (patternSize + i > tokens.length) {
      allElementsMatch=false;
      break;
    }
    if (startWithSentStart && i > 0) {
      allElementsMatch=false;
      break;
    }
    int matchingTokens=0;
    for (int k=0; (k < patternSize); k++) {
      if (elem != null) {
        prevElement=elem;
      }
      elem=patternElements.get(k);
      skipNext=translateElementNo(elem.getSkipNext());
      final int nextPos=tokenPos + k + skipShiftTotal;
      if (nextPos >= tokens.length) {
        allElementsMatch=false;
        break;
      }
      boolean skipMatch=false, thisMatched=false, prevMatched=false;
      boolean exceptionMatched=false;
      if (prevSkipNext + nextPos >= tokens.length || prevSkipNext < 0) {
        prevSkipNext=tokens.length - (nextPos + 1);
      }
      for (int m=nextPos; m <= nextPos + prevSkipNext; m++) {
        boolean matched=false;
        final int numberOfReadings=tokens[m].getReadingsLength();
        for (int l=0; l < numberOfReadings; l++) {
          final AnalyzedToken matchToken=tokens[m].getAnalyzedToken(l);
          if (prevSkipNext > 0 && prevElement != null) {
            if (prevElement.scopeNextExceptionMatch(matchToken)) {
              exceptionMatched=true;
              prevMatched=true;
            }
          }
          if (elem.referenceElement() && (firstMatchToken + elem.getMatch().getTokenRef() < tokens.length)) {
            elem.getMatch().setToken(tokens[firstMatchToken + elem.getMatch().getTokenRef()]);
            elem.getMatch().setSynthesizer(language[0].getSynthesizer());
            elem.compile();
          }
          if (elem.hasAndGroup()) {
            for (            final Element andElement : elem.getAndGroup()) {
              if (andElement.referenceElement() && (firstMatchToken + andElement.getMatch().getTokenRef() < tokens.length)) {
                andElement.getMatch().setToken(tokens[firstMatchToken + andElement.getMatch().getTokenRef()]);
                andElement.getMatch().setSynthesizer(language[0].getSynthesizer());
                andElement.compile();
              }
            }
            if (l == 0) {
              elem.setupAndGroup();
            }
          }
          thisMatched|=elem.match(matchToken) | elem.andGroupMatch(matchToken);
          if (l + 1 == numberOfReadings && elem.hasAndGroup()) {
            thisMatched&=elem.checkAndGroup(thisMatched);
          }
          exceptionMatched|=(elem.exceptionMatch(matchToken) || elem.andGroupExceptionMatch(matchToken));
          if (!exceptionMatched && elem.hasPreviousException() && m > 0) {
            final int numReadings=tokens[m - 1].getReadingsLength();
            for (int p=0; p < numReadings; p++) {
              exceptionMatched|=elem.scopePreviousExceptionMatch(tokens[m - 1].getAnalyzedToken(p));
            }
          }
          if (!(thisMatched || exceptionMatched)) {
            matched|=false;
          }
 else {
            matched=true;
            matchPos=m;
            skipShift=matchPos - nextPos;
            tokenPositions[matchingTokens]=skipShift + 1;
          }
          skipMatch=(skipMatch || matched) && !exceptionMatched;
        }
        if (!(thisMatched || prevMatched)) {
          exceptionMatched=false;
        }
        if (skipMatch) {
          break;
        }
      }
      if (!(thisMatched || prevMatched)) {
        skipMatch=false;
      }
      allElementsMatch=skipMatch;
      if (skipMatch) {
        prevSkipNext=skipNext;
      }
 else {
        prevSkipNext=0;
      }
      if (allElementsMatch) {
        matchingTokens++;
        lastMatchToken=matchPos;
        if (firstMatchToken == -1) {
          firstMatchToken=matchPos;
        }
        skipShiftTotal+=skipShift;
      }
 else {
        skipShiftTotal=0;
        break;
      }
    }
    tokenPos++;
    if (firstMatchToken + matchingTokens >= tokens.length) {
      matchingTokens=tokens.length - firstMatchToken;
    }
    if (firstMatchToken + skipShiftTotal + matchingTokens > tokens.length) {
      allElementsMatch=false;
    }
    if (allElementsMatch) {
      final String errMessage=formatMatches(tokens,tokenPositions,firstMatchToken,matchingTokens,message);
      int correctedStPos=0;
      if (startPositionCorrection > 0) {
        for (int l=0; l <= startPositionCorrection; l++) {
          correctedStPos+=tokenPositions[l];
        }
        correctedStPos--;
      }
      int correctedEndPos=0;
      if (endPositionCorrection < 0) {
        int l=0;
        while (l > endPositionCorrection) {
          int test=matchingTokens + l - 1;
          test=tokenPositions[test];
          correctedEndPos-=tokenPositions[matchingTokens + l - 1];
          l--;
        }
      }
      AnalyzedTokenReadings firstMatchTokenObj=tokens[firstMatchToken + correctedStPos];
      boolean startsWithUppercase=StringTools.startsWithUppercase(firstMatchTokenObj.toString());
      if (firstMatchTokenObj.isSentStart() && tokens.length > firstMatchToken + correctedStPos + 1) {
        firstMatchTokenObj=tokens[firstMatchToken + correctedStPos + 1];
        startsWithUppercase=StringTools.startsWithUppercase(firstMatchTokenObj.toString());
      }
      int fromPos=tokens[firstMatchToken + correctedStPos].getStartPos();
      if (errMessage.contains("<suggestion>,") && firstMatchToken + correctedStPos >= 1) {
        fromPos=tokens[firstMatchToken + correctedStPos - 1].getStartPos() + tokens[firstMatchToken + correctedStPos - 1].getToken().length();
      }
      final int toPos=tokens[lastMatchToken + correctedEndPos].getStartPos() + tokens[lastMatchToken + correctedEndPos].getToken().length();
      if (fromPos < toPos) {
        final RuleMatch ruleMatch=new RuleMatch(this,fromPos,toPos,errMessage,startsWithUppercase);
        ruleMatches.add(ruleMatch);
      }
    }
 else {
      firstMatchToken=-1;
      lastMatchToken=-1;
      skipShiftTotal=0;
    }
  }
  return ruleMatches.toArray(new RuleMatch[ruleMatches.size()]);
}
