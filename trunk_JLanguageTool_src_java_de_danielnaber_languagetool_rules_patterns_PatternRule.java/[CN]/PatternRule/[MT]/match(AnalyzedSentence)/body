{
  List<RuleMatch> ruleMatches=new ArrayList<RuleMatch>();
  AnalyzedTokenReadings[] tokens=text.getTokensWithoutWhitespace();
  int tokenPos=0;
  int prevSkipNext=0;
  int skipNext=0;
  int matchPos=0;
  int skipShift=0;
  int firstMatchToken=-1;
  int lastMatchToken=-1;
  Element elem=null, prevElement=null;
  for (int i=0; i < tokens.length; i++) {
    boolean allElementsMatch=true;
    int matchingTokens=0;
    for (int k=0; k < patternElements.size(); k++) {
      if (elem != null) {
        prevElement=elem;
      }
      elem=patternElements.get(k);
      skipNext=elem.getSkipNext();
      int nextPos=tokenPos + k + skipShift;
      if (nextPos >= tokens.length) {
        allElementsMatch=false;
        break;
      }
      boolean skipMatch=false, exceptionMatched=false;
      if (prevSkipNext + nextPos >= tokens.length || prevSkipNext < 0) {
        prevSkipNext=tokens.length - (nextPos + 1);
      }
      for (int m=nextPos; m <= nextPos + prevSkipNext; m++) {
        boolean matched=false;
        for (int l=0; l < tokens[m].getReadingsLength(); l++) {
          AnalyzedToken matchToken=tokens[m].getAnalyzedToken(l);
          if (prevSkipNext > 0 && prevElement != null) {
            if (prevElement.exceptionMatch(matchToken) && prevElement.exceptionValid()) {
              exceptionMatched=true;
            }
          }
          exceptionMatched=exceptionMatched || elem.exceptionMatch(matchToken);
          if (!(elem.match(matchToken) && !exceptionMatched)) {
            matched=matched || false;
          }
 else {
            matched=true;
            matchPos=m;
            skipShift=matchPos - nextPos;
          }
          skipMatch=(skipMatch || matched) && !exceptionMatched;
        }
        if (skipMatch) {
          break;
        }
      }
      allElementsMatch=skipMatch;
      if (skipMatch) {
        prevSkipNext=skipNext;
      }
 else {
        prevSkipNext=0;
      }
      if (!allElementsMatch) {
        break;
      }
 else {
        matchingTokens++;
        lastMatchToken=matchPos;
        if (firstMatchToken == -1)         firstMatchToken=matchPos;
      }
    }
    if (allElementsMatch) {
      String errMessage=message;
      for (int j=0; j < matchingTokens; j++) {
        errMessage=errMessage.replaceAll("\\\\" + (j + 1),tokens[firstMatchToken + j].getToken());
      }
      boolean startsWithUppercase=StringTools.startsWithUppercase(tokens[firstMatchToken + startPositionCorrection].toString());
      RuleMatch ruleMatch=new RuleMatch(this,tokens[firstMatchToken + startPositionCorrection].getStartPos(),tokens[lastMatchToken + endPositionCorrection].getStartPos() + tokens[lastMatchToken + endPositionCorrection].getToken().length(),errMessage,startsWithUppercase);
      ruleMatches.add(ruleMatch);
    }
 else {
      firstMatchToken=-1;
      lastMatchToken=-1;
    }
    tokenPos++;
  }
  return (RuleMatch[])ruleMatches.toArray(new RuleMatch[0]);
}
