{
  List ruleMatches=new ArrayList();
  AnalyzedToken[] tokens=text.getTokensWithoutWhitespace();
  if (patternElements == null) {
    patternElements=getPatternElements(pattern);
  }
  int tokenPos=0;
  int firstMatchToken=-1;
  int lastMatchToken=-1;
  for (int i=0; i < tokens.length; i++) {
    boolean allElementsMatch=true;
    int matchingTokens=0;
    for (int k=0; k < patternElements.length; k++) {
      Element elem=patternElements[k];
      int nextPos=tokenPos + k;
      if (nextPos >= tokens.length) {
        allElementsMatch=false;
        break;
      }
      AnalyzedToken matchToken=tokens[nextPos];
      if (!elem.match(matchToken)) {
        allElementsMatch=false;
        break;
      }
 else {
        matchingTokens++;
        lastMatchToken=nextPos;
        if (firstMatchToken == -1)         firstMatchToken=nextPos;
      }
    }
    if (allElementsMatch) {
      String errMessage=message;
      for (int j=0; j < matchingTokens; j++) {
        errMessage=errMessage.replaceAll("\\\\" + (j + 1),tokens[firstMatchToken + j].getToken());
      }
      int first=firstMatchToken + startPositionCorrection;
      int last=lastMatchToken + endPositionCorrection;
      if (first >= tokens.length || first < 0 || last >= tokens.length || last < 0) {
        throw new RuntimeException("Please fix the mark_from and/or mark_to attributes of rule " + getId() + " so that they don't point beyond the pattern.");
      }
      boolean startsWithUppercase=StringTools.startsWithUppercase(tokens[first].toString());
      RuleMatch ruleMatch=new RuleMatch(this,tokens[first].getStartPos(),tokens[last].getStartPos() + tokens[last].getToken().length(),errMessage,startsWithUppercase);
      ruleMatches.add(ruleMatch);
    }
 else {
      firstMatchToken=-1;
      lastMatchToken=-1;
    }
    tokenPos++;
  }
  return (RuleMatch[])ruleMatches.toArray(new RuleMatch[0]);
}
