{
  final AnalyzedTokenReadings[] whTokens=whiteTokens.clone();
  final DisambiguationPatternRule rule=(DisambiguationPatternRule)this.rule;
  int correctedStPos=0;
  int startPositionCorrection=rule.getStartPositionCorrection();
  int endPositionCorrection=rule.getEndPositionCorrection();
  if (startPositionCorrection > 0) {
    for (int l=0; l <= startPositionCorrection; l++) {
      correctedStPos+=tokenPositions[l];
    }
    correctedStPos--;
  }
  final int fromPos=text.getOriginalPosition(firstMatchToken + correctedStPos);
  final boolean spaceBefore=whTokens[fromPos].isWhitespaceBefore();
  boolean filtered=false;
  final DisambiguationPatternRule.DisambiguatorAction disAction=rule.getAction();
  final AnalyzedToken[] newTokenReadings=rule.getNewTokenReadings();
  final Match matchElement=rule.getMatchElement();
  final String disambiguatedPOS=rule.getDisambiguatedPOS();
switch (disAction) {
case UNIFY:
    if (unifiedTokens != null) {
      if (unifiedTokens.length == matchingTokens - startPositionCorrection + endPositionCorrection) {
        if (whTokens[text.getOriginalPosition(firstMatchToken + correctedStPos + unifiedTokens.length - 1)].isSentenceEnd()) {
          unifiedTokens[unifiedTokens.length - 1].setSentEnd();
        }
        for (int i=0; i < unifiedTokens.length; i++) {
          final int position=text.getOriginalPosition(firstMatchToken + correctedStPos + i);
          unifiedTokens[i].setStartPos(whTokens[position].getStartPos());
          final String prevValue=whTokens[position].toString();
          final String prevAnot=whTokens[position].getHistoricalAnnotations();
          whTokens[position]=unifiedTokens[i];
          annotateChange(whTokens[position],prevValue,prevAnot);
        }
      }
    }
  break;
case REMOVE:
if (newTokenReadings != null) {
  if (newTokenReadings.length == matchingTokens - startPositionCorrection + endPositionCorrection) {
    for (int i=0; i < newTokenReadings.length; i++) {
      final int position=text.getOriginalPosition(firstMatchToken + correctedStPos + i);
      final String prevValue=whTokens[position].toString();
      final String prevAnot=whTokens[position].getHistoricalAnnotations();
      whTokens[position].removeReading(newTokenReadings[i]);
      annotateChange(whTokens[position],prevValue,prevAnot);
    }
  }
}
break;
case ADD:
if (newTokenReadings != null) {
if (newTokenReadings.length == matchingTokens - startPositionCorrection + endPositionCorrection) {
for (int i=0; i < newTokenReadings.length; i++) {
  final String token;
  final int position=text.getOriginalPosition(firstMatchToken + correctedStPos + i);
  if ("".equals(newTokenReadings[i].getToken())) {
    token=whTokens[position].getToken();
  }
 else {
    token=newTokenReadings[i].getToken();
  }
  final String lemma;
  if (newTokenReadings[i].getLemma() == null) {
    lemma=token;
  }
 else {
    lemma=newTokenReadings[i].getLemma();
  }
  final AnalyzedToken newTok=new AnalyzedToken(token,newTokenReadings[i].getPOSTag(),lemma);
  newTok.setChunkTags(newTokenReadings[i].getChunkTags());
  final String prevValue=whTokens[position].toString();
  final String prevAnot=whTokens[position].getHistoricalAnnotations();
  whTokens[position].addReading(newTok);
  annotateChange(whTokens[position],prevValue,prevAnot);
}
}
}
break;
case FILTERALL:
for (int i=0; i < matchingTokens - startPositionCorrection + endPositionCorrection; i++) {
final int position=text.getOriginalPosition(firstMatchToken + correctedStPos + i);
final Element myEl=rule.getPatternElements().get(i + startPositionCorrection);
final Match tmpMatchToken=new Match(myEl.getPOStag(),null,true,myEl.getPOStag(),null,Match.CaseConversion.NONE,false,false,Match.IncludeRange.NONE);
MatchState matchState=tmpMatchToken.createState(rule.getLanguage().getSynthesizer(),whTokens[position]);
final String prevValue=whTokens[position].toString();
final String prevAnot=whTokens[position].getHistoricalAnnotations();
whTokens[position]=matchState.filterReadings();
annotateChange(whTokens[position],prevValue,prevAnot);
}
break;
case IMMUNIZE:
for (int i=0; i < matchingTokens - startPositionCorrection + endPositionCorrection; i++) {
whTokens[text.getOriginalPosition(firstMatchToken + correctedStPos + i)].immunize();
}
case FILTER:
if (matchElement == null) {
final Match tmpMatchToken=new Match(disambiguatedPOS,null,true,disambiguatedPOS,null,Match.CaseConversion.NONE,false,false,Match.IncludeRange.NONE);
final MatchState matchState=tmpMatchToken.createState(rule.getLanguage().getSynthesizer(),whTokens[fromPos]);
final String prevValue=whTokens[fromPos].toString();
final String prevAnot=whTokens[fromPos].getHistoricalAnnotations();
whTokens[fromPos]=matchState.filterReadings();
annotateChange(whTokens[fromPos],prevValue,prevAnot);
filtered=true;
}
case REPLACE:
default :
if (!filtered) {
if (newTokenReadings != null && newTokenReadings.length > 0) {
if (newTokenReadings.length == matchingTokens - startPositionCorrection + endPositionCorrection) {
for (int i=0; i < newTokenReadings.length; i++) {
final String token;
final int position=text.getOriginalPosition(firstMatchToken + correctedStPos + i);
if ("".equals(newTokenReadings[i].getToken())) {
token=whTokens[position].getToken();
}
 else {
token=newTokenReadings[i].getToken();
}
final String lemma;
if (newTokenReadings[i].getLemma() == null) {
lemma=token;
}
 else {
lemma=newTokenReadings[i].getLemma();
}
final AnalyzedToken analyzedToken=new AnalyzedToken(token,newTokenReadings[i].getPOSTag(),lemma);
analyzedToken.setChunkTags(newTokenReadings[i].getChunkTags());
final AnalyzedTokenReadings toReplace=new AnalyzedTokenReadings(analyzedToken,whTokens[fromPos].getStartPos());
whTokens[position]=replaceTokens(whTokens[position],toReplace);
}
}
}
 else if (matchElement == null) {
String lemma="";
for (AnalyzedToken analyzedToken : whTokens[fromPos]) {
if (analyzedToken.getPOSTag() != null && (analyzedToken.getPOSTag().equals(disambiguatedPOS) && (analyzedToken.getLemma() != null))) {
lemma=analyzedToken.getLemma();
}
}
if (StringTools.isEmpty(lemma)) {
lemma=whTokens[fromPos].getAnalyzedToken(0).getLemma();
}
final AnalyzedToken analyzedToken=new AnalyzedToken(whTokens[fromPos].getToken(),disambiguatedPOS,lemma);
analyzedToken.setChunkTags(whTokens[fromPos].getAnalyzedToken(0).getChunkTags());
final AnalyzedTokenReadings toReplace=new AnalyzedTokenReadings(analyzedToken,whTokens[fromPos].getStartPos());
whTokens[fromPos]=replaceTokens(whTokens[fromPos],toReplace);
}
 else {
final MatchState matchElementState=matchElement.createState(rule.getLanguage().getSynthesizer(),whTokens[fromPos]);
final String prevValue=whTokens[fromPos].toString();
final String prevAnot=whTokens[fromPos].getHistoricalAnnotations();
whTokens[fromPos]=matchElementState.filterReadings();
whTokens[fromPos].setWhitespaceBefore(spaceBefore);
annotateChange(whTokens[fromPos],prevValue,prevAnot);
}
}
}
return whTokens;
}
