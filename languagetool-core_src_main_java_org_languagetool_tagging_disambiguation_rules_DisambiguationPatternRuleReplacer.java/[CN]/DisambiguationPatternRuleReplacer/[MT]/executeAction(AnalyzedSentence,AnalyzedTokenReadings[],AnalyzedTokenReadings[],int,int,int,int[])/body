{
  final AnalyzedTokenReadings[] whTokens=whiteTokens.clone();
  final DisambiguationPatternRule rule=(DisambiguationPatternRule)this.rule;
  int correctedStPos=0;
  int startPositionCorrection=rule.getStartPositionCorrection();
  int endPositionCorrection=rule.getEndPositionCorrection();
  int matchingTokensWithCorrection=matchingTokens;
  if (matchingTokensWithCorrection - startPositionCorrection + endPositionCorrection == 0) {
    int k=startPositionCorrection;
    for (int j=0; j < k; j++) {
      if (!elementsMatched.get(j)) {
        startPositionCorrection--;
      }
    }
  }
  if (startPositionCorrection > 0) {
    for (int l=0; l <= startPositionCorrection; l++) {
      correctedStPos+=tokenPositions[l];
    }
    correctedStPos--;
  }
  for (int j=0; j <= startPositionCorrection; j++) {
    if (!elementsMatched.get(j)) {
      correctedStPos-=tokenPositions[j];
    }
  }
  int j=0;
  while (startPositionCorrection + j < rule.getPatternElements().size() && !elementsMatched.get(startPositionCorrection + j)) {
    correctedStPos++;
    j++;
  }
  if (lastMatchToken != -1) {
    int maxPosCorrection=0;
    maxPosCorrection=Math.max((lastMatchToken + 1 - (firstMatchToken + correctedStPos)) - matchingTokens,0);
    matchingTokensWithCorrection+=maxPosCorrection;
  }
  final int fromPos=sentence.getOriginalPosition(firstMatchToken + correctedStPos);
  final boolean spaceBefore=whTokens[fromPos].isWhitespaceBefore();
  boolean filtered=false;
  final DisambiguationPatternRule.DisambiguatorAction disAction=rule.getAction();
  final AnalyzedToken[] newTokenReadings=rule.getNewTokenReadings();
  final Match matchElement=rule.getMatchElement();
  final String disambiguatedPOS=rule.getDisambiguatedPOS();
switch (disAction) {
case UNIFY:
    if (unifiedTokens != null) {
      if (unifiedTokens.length == matchingTokensWithCorrection - startPositionCorrection + endPositionCorrection) {
        if (whTokens[sentence.getOriginalPosition(firstMatchToken + correctedStPos + unifiedTokens.length - 1)].isSentenceEnd()) {
          unifiedTokens[unifiedTokens.length - 1].setSentEnd();
        }
        for (int i=0; i < unifiedTokens.length; i++) {
          final int position=sentence.getOriginalPosition(firstMatchToken + correctedStPos + i);
          unifiedTokens[i].setStartPos(whTokens[position].getStartPos());
          final String prevValue=whTokens[position].toString();
          final String prevAnot=whTokens[position].getHistoricalAnnotations();
          whTokens[position]=unifiedTokens[i];
          annotateChange(whTokens[position],prevValue,prevAnot);
        }
      }
    }
  break;
case REMOVE:
if (newTokenReadings != null && newTokenReadings.length > 0) {
  if (newTokenReadings.length == matchingTokensWithCorrection - startPositionCorrection + endPositionCorrection) {
    for (int i=0; i < newTokenReadings.length; i++) {
      final int position=sentence.getOriginalPosition(firstMatchToken + correctedStPos + i);
      final String prevValue=whTokens[position].toString();
      final String prevAnot=whTokens[position].getHistoricalAnnotations();
      whTokens[position].removeReading(newTokenReadings[i]);
      annotateChange(whTokens[position],prevValue,prevAnot);
    }
  }
}
 else if (!StringTools.isEmpty(disambiguatedPOS)) {
  Pattern p=Pattern.compile(disambiguatedPOS);
  AnalyzedTokenReadings tmp=new AnalyzedTokenReadings(whTokens[fromPos].getReadings(),whTokens[fromPos].getStartPos());
  for (  AnalyzedToken analyzedToken : tmp) {
    if (analyzedToken.getPOSTag() != null) {
      final Matcher mPos=p.matcher(analyzedToken.getPOSTag());
      if (mPos.matches()) {
        final int position=sentence.getOriginalPosition(firstMatchToken + correctedStPos);
        final String prevValue=whTokens[position].toString();
        final String prevAnot=whTokens[position].getHistoricalAnnotations();
        whTokens[position].removeReading(analyzedToken);
        annotateChange(whTokens[position],prevValue,prevAnot);
      }
    }
  }
}
break;
case ADD:
if (newTokenReadings != null) {
if (newTokenReadings.length == matchingTokensWithCorrection - startPositionCorrection + endPositionCorrection) {
for (int i=0; i < newTokenReadings.length; i++) {
  final String token;
  final int position=sentence.getOriginalPosition(firstMatchToken + correctedStPos + i);
  if ("".equals(newTokenReadings[i].getToken())) {
    token=whTokens[position].getToken();
  }
 else {
    token=newTokenReadings[i].getToken();
  }
  final String lemma;
  if (newTokenReadings[i].getLemma() == null) {
    lemma=token;
  }
 else {
    lemma=newTokenReadings[i].getLemma();
  }
  final AnalyzedToken newTok=new AnalyzedToken(token,newTokenReadings[i].getPOSTag(),lemma);
  final String prevValue=whTokens[position].toString();
  final String prevAnot=whTokens[position].getHistoricalAnnotations();
  whTokens[position].addReading(newTok);
  annotateChange(whTokens[position],prevValue,prevAnot);
}
}
}
break;
case FILTERALL:
for (int i=0; i < matchingTokensWithCorrection - startPositionCorrection + endPositionCorrection; i++) {
final int position=sentence.getOriginalPosition(firstMatchToken + correctedStPos + i);
Element myEl;
if (elementsMatched.get(i + startPositionCorrection)) {
myEl=rule.getPatternElements().get(i + startPositionCorrection);
}
 else {
int k=1;
while (i + startPositionCorrection + k < rule.getPatternElements().size() + endPositionCorrection && !elementsMatched.get(i + startPositionCorrection + k)) {
k++;
}
assert(i + k + startPositionCorrection < rule.getPatternElements().size());
myEl=rule.getPatternElements().get(i + k + startPositionCorrection);
}
final Match tmpMatchToken=new Match(myEl.getPOStag(),null,true,myEl.getPOStag(),null,Match.CaseConversion.NONE,false,false,Match.IncludeRange.NONE);
MatchState matchState=tmpMatchToken.createState(rule.getLanguage().getSynthesizer(),whTokens[position]);
final String prevValue=whTokens[position].toString();
final String prevAnot=whTokens[position].getHistoricalAnnotations();
whTokens[position]=matchState.filterReadings();
annotateChange(whTokens[position],prevValue,prevAnot);
}
break;
case IMMUNIZE:
for (int i=0; i < matchingTokensWithCorrection - startPositionCorrection + endPositionCorrection; i++) {
whTokens[sentence.getOriginalPosition(firstMatchToken + correctedStPos + i)].immunize();
}
break;
case IGNORE_SPELLING:
for (int i=0; i < matchingTokensWithCorrection - startPositionCorrection + endPositionCorrection; i++) {
whTokens[sentence.getOriginalPosition(firstMatchToken + correctedStPos + i)].ignoreSpelling();
}
break;
case FILTER:
if (matchElement == null) {
final Match tmpMatchToken=new Match(disambiguatedPOS,null,true,disambiguatedPOS,null,Match.CaseConversion.NONE,false,false,Match.IncludeRange.NONE);
final MatchState matchState=tmpMatchToken.createState(rule.getLanguage().getSynthesizer(),whTokens[fromPos]);
final String prevValue=whTokens[fromPos].toString();
final String prevAnot=whTokens[fromPos].getHistoricalAnnotations();
whTokens[fromPos]=matchState.filterReadings();
annotateChange(whTokens[fromPos],prevValue,prevAnot);
filtered=true;
}
case REPLACE:
default :
if (!filtered) {
if (newTokenReadings != null && newTokenReadings.length > 0) {
if (newTokenReadings.length == matchingTokensWithCorrection - startPositionCorrection + endPositionCorrection) {
for (int i=0; i < newTokenReadings.length; i++) {
final String token;
final int position=sentence.getOriginalPosition(firstMatchToken + correctedStPos + i);
if ("".equals(newTokenReadings[i].getToken())) {
token=whTokens[position].getToken();
}
 else {
token=newTokenReadings[i].getToken();
}
final String lemma;
if (newTokenReadings[i].getLemma() == null) {
lemma=token;
}
 else {
lemma=newTokenReadings[i].getLemma();
}
final AnalyzedToken analyzedToken=new AnalyzedToken(token,newTokenReadings[i].getPOSTag(),lemma);
final AnalyzedTokenReadings toReplace=new AnalyzedTokenReadings(analyzedToken,whTokens[fromPos].getStartPos());
whTokens[position]=replaceTokens(whTokens[position],toReplace);
}
}
}
 else if (matchElement == null) {
String lemma="";
for (AnalyzedToken analyzedToken : whTokens[fromPos]) {
if (analyzedToken.getPOSTag() != null && analyzedToken.getPOSTag().equals(disambiguatedPOS) && analyzedToken.getLemma() != null) {
lemma=analyzedToken.getLemma();
}
}
if (StringTools.isEmpty(lemma)) {
lemma=whTokens[fromPos].getAnalyzedToken(0).getLemma();
}
final AnalyzedToken analyzedToken=new AnalyzedToken(whTokens[fromPos].getToken(),disambiguatedPOS,lemma);
final AnalyzedTokenReadings toReplace=new AnalyzedTokenReadings(analyzedToken,whTokens[fromPos].getStartPos());
whTokens[fromPos]=replaceTokens(whTokens[fromPos],toReplace);
}
 else {
final MatchState matchElementState=matchElement.createState(rule.getLanguage().getSynthesizer(),whTokens[fromPos]);
final String prevValue=whTokens[fromPos].toString();
final String prevAnot=whTokens[fromPos].getHistoricalAnnotations();
whTokens[fromPos]=matchElementState.filterReadings();
whTokens[fromPos].setWhitespaceBefore(spaceBefore);
annotateChange(whTokens[fromPos],prevValue,prevAnot);
}
}
}
return whTokens;
}
