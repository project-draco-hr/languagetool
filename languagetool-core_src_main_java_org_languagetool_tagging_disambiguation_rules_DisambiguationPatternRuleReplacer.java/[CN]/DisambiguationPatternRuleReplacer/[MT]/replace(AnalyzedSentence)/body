{
  List<ElementMatcher> elementMatchers=createElementMatchers();
  final AnalyzedTokenReadings[] tokens=sentence.getTokensWithoutWhitespace();
  AnalyzedTokenReadings[] whTokens=sentence.getTokens();
  final int[] tokenPositions=new int[tokens.length + 1];
  final int patternSize=elementMatchers.size();
  final int limit=Math.max(0,tokens.length - patternSize + 1);
  ElementMatcher elem=null;
  boolean changed=false;
  elementsMatched.clear();
  for (  ElementMatcher elementMatcher : elementMatchers) {
    elementsMatched.add(false);
  }
  int i=0;
  int minOccurCorrection=getMinOccurrenceCorrection();
  while (i < limit + minOccurCorrection && !(rule.isSentStart() && i > 0)) {
    boolean allElementsMatch=false;
    unifiedTokens=null;
    int matchingTokens=0;
    int skipShiftTotal=0;
    int firstMatchToken=-1;
    int lastMatchToken;
    int firstMarkerMatchToken=-1;
    int lastMarkerMatchToken=-1;
    int prevSkipNext=0;
    if (rule.isTestUnification()) {
      unifier.reset();
    }
    int minOccurSkip=0;
    for (int k=0; k < patternSize; k++) {
      final ElementMatcher prevElement=elem;
      elem=elementMatchers.get(k);
      elem.resolveReference(firstMatchToken,tokens,rule.getLanguage());
      final int nextPos=i + k + skipShiftTotal - minOccurSkip;
      prevMatched=false;
      if (prevSkipNext + nextPos >= tokens.length || prevSkipNext < 0) {
        prevSkipNext=tokens.length - (nextPos + 1);
      }
      final int maxTok=Math.min(nextPos + prevSkipNext,tokens.length - (patternSize - k) + minOccurCorrection);
      for (int m=nextPos; m <= maxTok; m++) {
        allElementsMatch=testAllReadings(tokens,elem,prevElement,m,firstMatchToken,prevSkipNext);
        if (elem.getElement().getMinOccurrence() == 0) {
          final ElementMatcher nextElement=elementMatchers.get(k + 1);
          final boolean nextElementMatch=testAllReadings(tokens,nextElement,elem,m,firstMatchToken,prevSkipNext);
          if (nextElementMatch) {
            allElementsMatch=true;
            minOccurSkip++;
            elementsMatched.set(k,false);
            break;
          }
        }
        if (allElementsMatch) {
          elementsMatched.set(k,true);
          int skipForMax=skipMaxTokens(tokens,elem,firstMatchToken,prevSkipNext,prevElement,m,patternSize - k - 1);
          lastMatchToken=m + skipForMax;
          final int skipShift=lastMatchToken - nextPos;
          tokenPositions[matchingTokens]=skipShift + 1;
          prevSkipNext=elem.getElement().getSkipNext();
          matchingTokens++;
          skipShiftTotal+=skipShift;
          if (firstMatchToken == -1) {
            firstMatchToken=lastMatchToken - skipForMax;
          }
          if (firstMarkerMatchToken == -1 && elem.getElement().isInsideMarker()) {
            firstMarkerMatchToken=lastMatchToken - skipForMax;
          }
          if (elem.getElement().isInsideMarker()) {
            lastMarkerMatchToken=lastMatchToken;
          }
          break;
        }
      }
      if (!allElementsMatch) {
        break;
      }
    }
    if (allElementsMatch && matchingTokens == patternSize || matchingTokens == patternSize - minOccurSkip && firstMatchToken != -1) {
      whTokens=executeAction(sentence,whTokens,unifiedTokens,firstMatchToken,lastMarkerMatchToken,matchingTokens,tokenPositions);
      changed=true;
    }
    i++;
  }
  if (changed) {
    return new AnalyzedSentence(whTokens,sentence.getWhPositions());
  }
  return sentence;
}
