{
switch (qName) {
case "category":
    categoryIssueType=null;
  break;
case RULE:
suggestionMatchesOutMsg=addLegacyMatches(suggestionMatchesOutMsg,suggestionsOutMsg.toString(),false);
phraseElementInit();
if (relaxedMode && id == null) {
id="";
}
if (relaxedMode && name == null) {
name="";
}
if (phraseElementList.isEmpty()) {
final List<Element> tmpElements=new ArrayList<>();
createRules(new ArrayList<>(elementList),tmpElements,0);
}
 else {
if (!elementList.isEmpty()) {
for (List<Element> ph : phraseElementList) {
ph.addAll(new ArrayList<>(elementList));
}
}
for (List<Element> phraseElement : phraseElementList) {
processElement(phraseElement);
final List<Element> tmpElements=new ArrayList<>();
createRules(phraseElement,tmpElements,0);
}
}
elementList.clear();
if (phraseElementList != null) {
phraseElementList.clear();
}
ruleIssueType=null;
inRule=false;
filterClassName=null;
filterArgs=null;
break;
case EXCEPTION:
finalizeExceptions();
break;
case AND:
inAndGroup=false;
andGroupCounter=0;
tokenCounter++;
break;
case OR:
inOrGroup=false;
orGroupCounter=0;
tokenCounter++;
break;
case TOKEN:
finalizeTokens();
break;
case PATTERN:
inPattern=false;
if (lastPhrase) {
elementList.clear();
}
tokenCounter=0;
break;
case ANTIPATTERN:
String antiId=id;
if (inRuleGroup) {
if (subId > 0) {
antiId=ruleGroupId + "[" + subId+ "]";
}
 else {
antiId=ruleGroupId;
}
}
final DisambiguationPatternRule rule=new DisambiguationPatternRule(antiId + "_antipattern:" + antiPatternCounter,"antipattern",language,elementList,null,null,DisambiguationPatternRule.DisambiguatorAction.IMMUNIZE);
if (startPos != -1 && endPos != -1) {
rule.setStartPositionCorrection(startPos);
rule.setEndPositionCorrection(endPos - tokenCountForMarker);
}
 else {
for (Element element : elementList) {
element.setInsideMarker(true);
}
}
elementList.clear();
if (inRule) {
if (ruleAntiPatterns == null) {
ruleAntiPatterns=new ArrayList<>();
}
ruleAntiPatterns.add(rule);
}
 else {
if (rulegroupAntiPatterns == null) {
rulegroupAntiPatterns=new ArrayList<>();
}
rulegroupAntiPatterns.add(rule);
}
tokenCounter=0;
inAntiPattern=false;
break;
case EXAMPLE:
if (inCorrectExample) {
correctExamples.add(correctExample.toString());
}
 else if (inIncorrectExample) {
final IncorrectExample example;
final List<String> corrections=new ArrayList<>();
corrections.addAll(Arrays.asList(exampleCorrection.toString().split("\\|")));
if (corrections.size() > 0) {
if (exampleCorrection.toString().endsWith("|")) {
corrections.add("");
}
example=new IncorrectExample(incorrectExample.toString(),corrections);
}
 else {
example=new IncorrectExample(incorrectExample.toString());
}
incorrectExamples.add(example);
}
inCorrectExample=false;
inIncorrectExample=false;
correctExample=new StringBuilder();
incorrectExample=new StringBuilder();
exampleCorrection=new StringBuilder();
break;
case MESSAGE:
suggestionMatches=addLegacyMatches(suggestionMatches,message.toString(),true);
inMessage=false;
break;
case SUGGESTION:
if (inMessage) {
message.append("</suggestion>");
}
 else {
suggestionsOutMsg.append("</suggestion>");
}
inSuggestion=false;
break;
case "short":
inShortMessage=false;
inShortMessageForRuleGroup=false;
break;
case "url":
inUrl=false;
inUrlForRuleGroup=false;
break;
case MATCH:
if (inMessage) {
suggestionMatches.get(suggestionMatches.size() - 1).setLemmaString(match.toString());
}
 else if (inSuggestion) {
suggestionMatchesOutMsg.get(suggestionMatchesOutMsg.size() - 1).setLemmaString(match.toString());
}
 else if (inToken) {
tokenReference.setLemmaString(match.toString());
}
inMatch=false;
break;
case RULEGROUP:
urlForRuleGroup=new StringBuilder();
shortMessageForRuleGroup=new StringBuilder();
inRuleGroup=false;
ruleGroupIssueType=null;
if (rulegroupAntiPatterns != null) {
rulegroupAntiPatterns.clear();
}
antiPatternCounter=0;
ruleGroupDefaultOff=false;
defaultOff=false;
defaultOn=false;
break;
case MARKER:
if (inCorrectExample) {
correctExample.append("</marker>");
}
 else if (inIncorrectExample) {
incorrectExample.append("</marker>");
}
 else if (inPattern || inAntiPattern) {
endPos=tokenCountForMarker;
inMarker=false;
}
break;
case "phrase":
if (inPhrases) {
finalizePhrase();
}
break;
case "includephrases":
elementList.clear();
break;
case PHRASES:
if (inPhrases) {
inPhrases=false;
}
break;
case UNIFICATION:
inUnificationDef=false;
break;
case FEATURE:
equivalenceFeatures.put(uFeature,uTypeList);
uTypeList=new ArrayList<>();
break;
case UNIFY:
inUnification=false;
equivalenceFeatures=new HashMap<>();
final int lastElement=elementList.size() - 1;
elementList.get(lastElement).setLastInUnification();
if (uniNegation) {
elementList.get(lastElement).setUniNegation();
}
break;
case UNIFY_IGNORE:
inUnificationNeutral=false;
break;
}
}
