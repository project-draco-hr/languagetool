{
  if ("category".equals(qName)) {
    categoryIssueType=null;
  }
 else   if (RULE.equals(qName)) {
    suggestionMatchesOutMsg=addLegacyMatches(suggestionMatchesOutMsg,suggestionsOutMsg.toString(),false);
    phraseElementInit();
    if (relaxedMode && id == null) {
      id="";
    }
    if (relaxedMode && name == null) {
      name="";
    }
    if (phraseElementList.isEmpty()) {
      final PatternRule rule=new PatternRule(id,language,elementList,name,message.toString(),shortMessage.toString(),suggestionsOutMsg.toString());
      prepareRule(rule);
      rules.add(rule);
    }
 else {
      if (!elementList.isEmpty()) {
        for (        final ArrayList<Element> ph : phraseElementList) {
          ph.addAll(new ArrayList<Element>(elementList));
        }
      }
      for (      final ArrayList<Element> phraseElement : phraseElementList) {
        processElement(phraseElement);
        final PatternRule rule=new PatternRule(id,language,phraseElement,name,message.toString(),shortMessage.toString(),suggestionsOutMsg.toString(),phraseElementList.size() > 1);
        prepareRule(rule);
        rules.add(rule);
      }
    }
    elementList.clear();
    if (phraseElementList != null) {
      phraseElementList.clear();
    }
    ruleIssueType=null;
  }
 else   if (EXCEPTION.equals(qName)) {
    finalizeExceptions();
  }
 else   if (AND.equals(qName)) {
    inAndGroup=false;
    andGroupCounter=0;
    tokenCounter++;
  }
 else   if (TOKEN.equals(qName)) {
    finalizeTokens();
  }
 else   if (PATTERN.equals(qName)) {
    inPattern=false;
    if (lastPhrase) {
      elementList.clear();
    }
    tokenCounter=0;
  }
 else   if (EXAMPLE.equals(qName)) {
    if (inCorrectExample) {
      correctExamples.add(correctExample.toString());
    }
 else     if (inIncorrectExample) {
      final IncorrectExample example;
      final String[] corrections=exampleCorrection.toString().split("\\|");
      if (corrections.length > 0 && corrections[0].length() > 0) {
        example=new IncorrectExample(incorrectExample.toString(),corrections);
      }
 else {
        example=new IncorrectExample(incorrectExample.toString());
      }
      incorrectExamples.add(example);
    }
    inCorrectExample=false;
    inIncorrectExample=false;
    correctExample=new StringBuilder();
    incorrectExample=new StringBuilder();
    exampleCorrection=new StringBuilder();
  }
 else   if (MESSAGE.equals(qName)) {
    suggestionMatches=addLegacyMatches(suggestionMatches,message.toString(),true);
    inMessage=false;
  }
 else   if ("suggestion".equals(qName) && !inMessage) {
    suggestionsOutMsg.append("</suggestion>");
    inSuggestion=false;
  }
 else   if ("short".equals(qName)) {
    inShortMessage=false;
  }
 else   if ("url".equals(qName)) {
    inUrl=false;
  }
 else   if (MATCH.equals(qName)) {
    if (inMessage) {
      suggestionMatches.get(suggestionMatches.size() - 1).setLemmaString(match.toString());
    }
 else     if (inSuggestion) {
      suggestionMatchesOutMsg.get(suggestionMatchesOutMsg.size() - 1).setLemmaString(match.toString());
    }
 else     if (inToken) {
      tokenReference.setLemmaString(match.toString());
    }
    inMatch=false;
  }
 else   if (RULEGROUP.equals(qName)) {
    inRuleGroup=false;
    ruleGroupIssueType=null;
  }
 else   if ("suggestion".equals(qName) && inMessage) {
    message.append("</suggestion>");
    inSuggestion=false;
  }
 else   if (MARKER.equals(qName) && inCorrectExample) {
    correctExample.append("</marker>");
  }
 else   if (MARKER.equals(qName) && inIncorrectExample) {
    incorrectExample.append("</marker>");
  }
 else   if (MARKER.equals(qName) && inPattern) {
    endPos=tokenCountForMarker;
  }
 else   if ("phrase".equals(qName) && inPhrases) {
    finalizePhrase();
  }
 else   if ("includephrases".equals(qName)) {
    elementList.clear();
  }
 else   if (PHRASES.equals(qName) && inPhrases) {
    inPhrases=false;
  }
 else   if (UNIFICATION.equals(qName)) {
    inUnificationDef=false;
  }
 else   if (FEATURE.equals(qName)) {
    equivalenceFeatures.put(uFeature,uTypeList);
    uTypeList=new ArrayList<String>();
  }
 else   if (UNIFY.equals(qName)) {
    inUnification=false;
    equivalenceFeatures=new HashMap<String,List<String>>();
    final int lastElement=elementList.size() - 1;
    elementList.get(lastElement).setLastInUnification();
    if (uniNegation) {
      elementList.get(lastElement).setUniNegation();
    }
  }
}
