{
  final List<RuleMatch> ruleMatches=new ArrayList<>();
  final AnalyzedTokenReadings[] tokens=sentence.getTokensWithoutWhitespace();
  for (  AnalyzedTokenReadings tmpToken : tokens) {
    String token=tmpToken.getToken();
    final String origToken=token;
    final List<AnalyzedToken> readings=tmpToken.getReadings();
    if (readings.size() > 0) {
      final String baseform=readings.get(0).getLemma();
      if (baseform != null) {
        token=baseform;
      }
    }
    if (shouldNotAppearWord.containsKey(token)) {
      final RuleMatch otherMatch=shouldNotAppearWord.get(token);
      final String otherSpelling=otherMatch.getMessage();
      final String msg=getMessage(token,otherSpelling);
      final RuleMatch ruleMatch=new RuleMatch(this,tmpToken.getStartPos(),tmpToken.getStartPos() + origToken.length(),msg);
      ruleMatch.setSuggestedReplacement(otherSpelling);
      ruleMatches.add(ruleMatch);
    }
 else     if (relevantWords.containsKey(token)) {
      final String shouldNotAppear=relevantWords.get(token);
      final RuleMatch potentialRuleMatch=new RuleMatch(this,tmpToken.getStartPos(),tmpToken.getStartPos() + origToken.length(),token);
      shouldNotAppearWord.put(shouldNotAppear,potentialRuleMatch);
    }
  }
  return toRuleMatchArray(ruleMatches);
}
