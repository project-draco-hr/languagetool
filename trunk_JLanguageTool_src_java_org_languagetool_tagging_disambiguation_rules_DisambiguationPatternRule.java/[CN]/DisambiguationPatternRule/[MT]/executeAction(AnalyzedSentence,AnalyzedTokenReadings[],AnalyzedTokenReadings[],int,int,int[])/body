{
  final AnalyzedTokenReadings[] whTokens=whiteTokens.clone();
  int correctedStPos=0;
  if (startPositionCorrection > 0) {
    for (int l=0; l <= startPositionCorrection; l++) {
      correctedStPos+=tokenPositions[l];
    }
    correctedStPos--;
  }
  int correctedEndPos=0;
  if (endPositionCorrection < 0) {
    int l=0;
    while (l > endPositionCorrection) {
      correctedEndPos-=tokenPositions[matchingTokens + l - 1];
      l--;
    }
  }
  final int fromPos=text.getOriginalPosition(firstMatchToken + correctedStPos);
  final int numRead=whTokens[fromPos].getReadingsLength();
  final boolean spaceBefore=whTokens[fromPos].isWhitespaceBefore();
  boolean filtered=false;
switch (disAction) {
case UNIFY:
    if (unifiedTokens != null) {
      if (unifiedTokens.length == matchingTokens - startPositionCorrection + endPositionCorrection) {
        if (whTokens[text.getOriginalPosition(firstMatchToken + correctedStPos + unifiedTokens.length - 1)].isSentEnd()) {
          unifiedTokens[unifiedTokens.length - 1].setSentEnd();
        }
        for (int i=0; i < unifiedTokens.length; i++) {
          unifiedTokens[i].setStartPos(whTokens[text.getOriginalPosition(firstMatchToken + correctedStPos + i)].getStartPos());
          whTokens[text.getOriginalPosition(firstMatchToken + correctedStPos + i)]=unifiedTokens[i];
        }
      }
    }
  break;
case REMOVE:
if (newTokenReadings != null) {
  if (newTokenReadings.length == matchingTokens - startPositionCorrection + endPositionCorrection) {
    for (int i=0; i < newTokenReadings.length; i++) {
      whTokens[text.getOriginalPosition(firstMatchToken + correctedStPos + i)].removeReading(newTokenReadings[i]);
    }
  }
}
break;
case ADD:
if (newTokenReadings != null) {
if (newTokenReadings.length == matchingTokens - startPositionCorrection + endPositionCorrection) {
String lemma="";
String token="";
for (int i=0; i < newTokenReadings.length; i++) {
  if ("".equals(newTokenReadings[i].getToken())) {
    token=whTokens[text.getOriginalPosition(firstMatchToken + correctedStPos + i)].getToken();
  }
 else {
    token=newTokenReadings[i].getToken();
  }
  if (newTokenReadings[i].getLemma() == null) {
    lemma=token;
  }
 else {
    lemma=newTokenReadings[i].getLemma();
  }
  final AnalyzedToken newTok=new AnalyzedToken(token,newTokenReadings[i].getPOSTag(),lemma);
  whTokens[text.getOriginalPosition(firstMatchToken + correctedStPos + i)].addReading(newTok);
}
}
}
break;
case IMMUNIZE:
for (int i=0; i < matchingTokens - startPositionCorrection + endPositionCorrection; i++) {
whTokens[text.getOriginalPosition(firstMatchToken + correctedStPos + i)].immunize();
}
case FILTER:
if (matchElement == null) {
final Match tmpMatchToken=new Match(disambiguatedPOS,null,true,disambiguatedPOS,null,Match.CaseConversion.NONE,false,false,Match.IncludeRange.NONE);
tmpMatchToken.setToken(whTokens[fromPos]);
whTokens[fromPos]=tmpMatchToken.filterReadings();
filtered=true;
}
case REPLACE:
default :
if (!filtered) {
if (matchElement == null) {
String lemma="";
for (int l=0; l < numRead; l++) {
if (whTokens[fromPos].getAnalyzedToken(l).getPOSTag() != null && (whTokens[fromPos].getAnalyzedToken(l).getPOSTag().equals(disambiguatedPOS) && (whTokens[fromPos].getAnalyzedToken(l).getLemma() != null))) {
lemma=whTokens[fromPos].getAnalyzedToken(l).getLemma();
}
}
if (StringTools.isEmpty(lemma)) {
lemma=whTokens[fromPos].getAnalyzedToken(0).getLemma();
}
final AnalyzedTokenReadings toReplace=new AnalyzedTokenReadings(new AnalyzedToken(whTokens[fromPos].getToken(),disambiguatedPOS,lemma),whTokens[fromPos].getStartPos());
final boolean isSentEnd=whTokens[fromPos].isSentEnd();
final boolean isParaEnd=whTokens[fromPos].isParaEnd();
whTokens[fromPos]=toReplace;
if (isSentEnd) {
whTokens[fromPos].setSentEnd();
}
if (isParaEnd) {
whTokens[fromPos].setParaEnd();
}
whTokens[fromPos].setWhitespaceBefore(spaceBefore);
}
 else {
matchElement.setToken(whTokens[fromPos]);
whTokens[fromPos]=matchElement.filterReadings();
whTokens[fromPos].setWhitespaceBefore(spaceBefore);
}
}
}
return whTokens;
}
