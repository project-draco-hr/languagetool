{
  boolean negative=false;
  boolean had_digits=false;
  int tries=0;
  while (inArray[index] != ' ' && inArray[index] != '(' && tries < 100) {
    ++tries;
    if (inArray[index] == '*' && inArray[index + 1] == '*') {
      currentTest.pos.add(POS.POS_SCANALL.value);
      index+=2;
    }
    if (inArray[index] == '*') {
      currentTest.pos.add(POS.POS_SCANFIRST.value);
      ++index;
    }
    if (inArray[index] == 'C') {
      currentTest.pos.add(POS.POS_CAREFUL.value);
      ++index;
    }
    if (inArray[index] == 'c') {
      currentTest.pos.add(POS.POS_DEP_CHILD.value);
      ++index;
    }
    if (inArray[index] == 'p') {
      currentTest.pos.add(POS.POS_DEP_PARENT.value);
      ++index;
    }
    if (inArray[index] == 's') {
      currentTest.pos.add(POS.POS_DEP_SIBLING.value);
      ++index;
    }
    if (inArray[index] == 'S') {
      currentTest.pos.add(POS.POS_SELF.value);
      ++index;
    }
    if (inArray[index] == '<') {
      currentTest.pos.add(POS.POS_SPAN_LEFT.value);
      ++index;
    }
    if (inArray[index] == '>') {
      currentTest.pos.add(POS.POS_SPAN_RIGHT.value);
      ++index;
    }
    if (inArray[index] == 'W') {
      currentTest.pos.add(POS.POS_SPAN_BOTH.value);
      ++index;
    }
    if (inArray[index] == '@') {
      currentTest.pos.add(POS.POS_ABSOLUTE.value);
      ++index;
    }
    if (inArray[index] == 'O') {
      currentTest.pos.add(POS.POS_NO_PASS_ORIGIN.value);
      ++index;
    }
    if (inArray[index] == 'o') {
      currentTest.pos.add(POS.POS_PASS_ORIGIN.value);
      ++index;
    }
    if (inArray[index] == 'L') {
      currentTest.pos.add(POS.POS_LEFT_PAR.value);
      ++index;
    }
    if (inArray[index] == 'R') {
      currentTest.pos.add(POS.POS_RIGHT_PAR.value);
      ++index;
    }
    if (inArray[index] == 'X') {
      currentTest.pos.add(POS.POS_MARK_SET.value);
      ++index;
    }
    if (inArray[index] == 'x') {
      currentTest.pos.add(POS.POS_MARK_JUMP.value);
      ++index;
    }
    if (inArray[index] == 'D') {
      currentTest.pos.add(POS.POS_LOOK_DELETED.value);
      ++index;
    }
    if (inArray[index] == 'd') {
      currentTest.pos.add(POS.POS_LOOK_DELAYED.value);
      ++index;
    }
    if (inArray[index] == 'A') {
      currentTest.pos.add(POS.POS_ATTACH_TO.value);
      ++index;
    }
    if (inArray[index] == '?') {
      currentTest.pos.add(POS.POS_UNKNOWN.value);
      ++index;
    }
    if (inArray[index] == '-') {
      negative=true;
      ++index;
    }
    if (Character.isDigit(inArray[index])) {
      had_digits=true;
      while (inArray[index] >= '0' && inArray[index] <= '9') {
        currentTest.offset=(currentTest.offset * 10) + (inArray[index] - '0');
        ++index;
      }
    }
    if (inArray[index] == 'r' && inArray[index + 1] == ':') {
      currentTest.pos.add(POS.POS_RELATION.value);
      index+=2;
      nindex=index;
      SKIPTOWS_N('(',true);
      StringBuilder sb=new StringBuilder();
      for (int i=index; i < nindex; i++) {
        sb.append(inArray[i]);
      }
      CgTag tag=result.allocateTag(sb.toString(),true);
      currentTest.relation=tag.hash;
      index=nindex;
    }
  }
  if (negative) {
    currentTest.offset=(-1) * Math.abs(currentTest.offset);
  }
  if ((currentTest.pos.contains(POS.POS_DEP_CHILD.value) || currentTest.pos.contains(POS.POS_DEP_SIBLING.value)) && currentTest.pos.contains(POS.POS_SCANFIRST.value) || currentTest.pos.contains(POS.POS_SCANALL.value)) {
    if (currentTest.pos.contains(POS.POS_SCANFIRST.value)) {
      currentTest.pos.remove(POS.POS_SCANFIRST.value);
    }
    if (currentTest.pos.contains(POS.POS_SCANALL.value)) {
      currentTest.pos.remove(POS.POS_SCANALL.value);
    }
    currentTest.pos.add(POS.POS_DEP_DEEP.value);
  }
  if ((currentTest.pos.contains(POS.POS_DEP_CHILD.value) || currentTest.pos.contains(POS.POS_DEP_SIBLING.value)) && currentTest.pos.contains(POS.POS_CAREFUL.value)) {
    System.out.println("Warning: deprecated conversion from C to ALL on line " + result.lines);
    if (currentTest.pos.contains(POS.POS_CAREFUL.value)) {
      currentTest.pos.remove(POS.POS_CAREFUL.value);
    }
    currentTest.pos.add(POS.POS_ALL.value);
  }
  if ((currentTest.pos.contains(POS.POS_DEP_CHILD.value) || currentTest.pos.contains(POS.POS_DEP_SIBLING.value)) && currentTest.pos.contains(POS.POS_NOT.value)) {
    System.out.println("Warning: deprecated conversion from NOT to NONE on line " + result.lines);
    if (currentTest.pos.contains(POS.POS_NOT.value)) {
      currentTest.pos.remove(POS.POS_NOT.value);
    }
    currentTest.pos.add(POS.POS_NONE.value);
  }
  if (currentTest.pos.contains(POS.POS_RELATION.value) && (currentTest.pos.contains(POS.POS_CAREFUL.value))) {
    System.out.println("Warning: deprecated conversion from C to ALL on line " + result.lines);
    currentTest.pos.remove(POS.POS_CAREFUL.value);
    currentTest.pos.add(POS.POS_NONE.value);
  }
  if (currentTest.pos.contains(POS.POS_RELATION.value) && (currentTest.pos.contains(POS.POS_NOT.value))) {
    System.out.println("Warning: deprecated from NOT to NONE on line " + result.lines);
    currentTest.pos.remove(POS.POS_NOT.value);
    currentTest.pos.add(POS.POS_NONE.value);
  }
  if (tries >= 5) {
    System.out.println("Warning: Position on line " + result.lines + " took too many loops");
  }
  if (tries >= 100) {
    System.err.println("Error: invalid position on line " + result.lines + " caused endless loop");
    System.exit(1);
  }
  if (had_digits) {
    if (currentTest.pos.contains(POS.POS_DEP_CHILD.value) || currentTest.pos.contains(POS.POS_DEP_SIBLING.value) || currentTest.pos.contains(POS.POS_DEP_PARENT.value)) {
      System.err.println("Error: invalid position on line " + result.lines + " - cannot combine offsets with dependency");
      System.exit(1);
    }
    if (currentTest.pos.contains(POS.POS_LEFT_PAR.value) || currentTest.pos.contains(POS.POS_RIGHT_PAR.value)) {
      System.err.println("Error: invalid position on line " + result.lines + " - cannot combine offsets with enclosures");
      System.exit(1);
    }
    if (currentTest.pos.contains(POS.POS_RELATION.value)) {
      System.err.println("Error: invalid position on line " + result.lines + " - cannot combine offsets with relations");
      System.exit(1);
    }
  }
  if ((currentTest.pos.contains(POS.POS_LEFT_PAR.value) || currentTest.pos.contains(POS.POS_RIGHT_PAR.value)) && (currentTest.pos.contains(POS.POS_SCANFIRST.value) || currentTest.pos.contains(POS.POS_SCANALL.value))) {
    System.err.println("Error: invalid position on line " + result.lines + " - cannot have both enclosure and scan");
    System.exit(1);
  }
  if (currentTest.pos.contains(POS.POS_PASS_ORIGIN.value) && currentTest.pos.contains(POS.POS_NO_PASS_ORIGIN.value)) {
    System.err.println("Error: invalid position on line " + result.lines + " - cannot have both O and o");
    System.exit(1);
  }
  if (currentTest.pos.contains(POS.POS_LEFT_PAR.value) && currentTest.pos.contains(POS.POS_RIGHT_PAR.value)) {
    System.err.println("Error: invalid position on line " + result.lines + " - cannot have both L and R");
    System.exit(1);
  }
  if (currentTest.pos.contains(POS.POS_ALL.value) && currentTest.pos.contains(POS.POS_NONE.value)) {
    System.err.println("Error: invalid position on line " + result.lines + " - cannot have both NONE and ALL");
    System.exit(1);
  }
  if (currentTest.pos.contains(POS.POS_UNKNOWN.value) && (currentTest.pos.size() == 1 || had_digits)) {
    System.err.println("Error: invalid position on line " + result.lines + " - ? cannot be combined with anything else");
    System.exit(1);
  }
  if (currentTest.pos.contains(POS.POS_SCANALL.value) && currentTest.pos.contains(POS.POS_NOT.value)) {
    System.out.println("Warning: we don't think mixing NOT and ** makes sense on line " + result.lines);
  }
}
