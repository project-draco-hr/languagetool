def check(self, text):
    'Check a text string and return the results as an XML formatted list\n\t\tof possible errors.'
    splitter = SentenceSplitter.SentenceSplitter()
    sentences = splitter.split(text)
    rule_matches = []
    char_counter = 0
    all_tagged_words = []
    line_counter = 1
    for sentence in sentences:
        tagged_words = self.tagger.tagText(sentence)
        chunks = self.chunker.chunk(tagged_words)
        tagged_words.insert(0, ('', None, 'SENT_START'))
        tagged_words.append(('', None, 'SENT_END'))
        all_tagged_words.extend(tagged_words)
        for rule in self.rules.rules:
            matches = rule.match(tagged_words, chunks, char_counter, line_counter)
            rule_matches.extend(matches)
        for triple in sentence:
            char_counter = (char_counter + len(triple[0]))
        line_counter = (line_counter + Tools.Tools.countLinebreaks(sentence))
    if ((not self.builtin) or ('WHITESPACE' in self.builtin)):
        whitespace_rule = Rules.WhitespaceRule()
        rule_matches.extend(whitespace_rule.match(all_tagged_words))
    rule_match_list = []
    context = 10
    for rule_match in rule_matches:
        if self.xml_output:
            rule_match_list.append(rule_match.toXML())
            rule_match_list.append('\n')
        else:
            rule_match_list.append(str(rule_match))
            rule_match_list.append('\n')
    result = string.join(rule_match_list, '')
    if self.xml_output:
        result = ('<errors>\n%s</errors>' % result)
    return (rule_matches, result, all_tagged_words)
