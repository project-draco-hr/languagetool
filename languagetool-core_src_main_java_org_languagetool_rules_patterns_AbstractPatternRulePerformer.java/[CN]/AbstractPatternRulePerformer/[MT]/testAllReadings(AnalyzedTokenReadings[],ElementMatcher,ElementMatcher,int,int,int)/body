{
  boolean thisMatched=false;
  final int numberOfReadings=tokens[tokenNo].getReadingsLength();
  elem.prepareAndGroup(firstMatchToken,tokens,rule.getLanguage());
  for (int l=0; l < numberOfReadings; l++) {
    final AnalyzedToken matchToken=tokens[tokenNo].getAnalyzedToken(l);
    boolean tested=false;
    prevMatched=prevMatched || prevSkipNext > 0 && prevElement != null && prevElement.isMatchedByScopeNextException(matchToken);
    if (prevMatched) {
      return false;
    }
    if (!thisMatched) {
      thisMatched=elem.isMatched(matchToken);
      tested=true;
    }
    if (!thisMatched && (prevElement == null || prevElement.getElement().getExceptionList() == null)) {
      if (elem.getElement().getPOStag() == null) {
        if (elem.getElement().isInflected()) {
          if (tokens[tokenNo].hasSameLemmas()) {
            return false;
          }
        }
 else {
          return false;
        }
      }
 else       if (!elem.getElement().getPOSNegation() && !tokens[tokenNo].isTagged()) {
        return false;
      }
    }
    if (rule.isGroupsOrUnification()) {
      if (!elem.getElement().isUnificationNeutral()) {
        thisMatched&=testUnificationAndGroups(thisMatched,l + 1 == numberOfReadings,matchToken,elem,tested);
      }
    }
  }
  if (thisMatched) {
    for (int l=0; l < numberOfReadings; l++) {
      if (elem.isExceptionMatchedCompletely(tokens[tokenNo].getAnalyzedToken(l))) {
        return false;
      }
    }
    if (tokenNo > 0 && elem.hasPreviousException()) {
      if (elem.isMatchedByPreviousException(tokens[tokenNo - 1])) {
        return false;
      }
    }
    if (elem.getElement().isUnificationNeutral()) {
      unifier.addNeutralElement(tokens[tokenNo]);
    }
  }
  if (elem.getElement().getChunkTag() != null) {
    thisMatched&=tokens[tokenNo].getChunkTags().contains(elem.getElement().getChunkTag()) ^ elem.getElement().getNegation();
  }
  if (elem.getElement().hasAndGroup()) {
    for (    Element e : elem.getElement().getAndGroup()) {
      if (e.getChunkTag() != null) {
        thisMatched&=tokens[tokenNo].getChunkTags().contains(e.getChunkTag()) ^ e.getNegation();
      }
    }
  }
  return thisMatched;
}
