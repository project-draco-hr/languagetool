def tag(self, data_table, seqs_table_followed_by, seqs_table_follows):
    'Tag self.text and return list of tuples\n\t\t(word, normalized word, most probable tag)'
    self.text = self.expandEntities(self.text)
    is_bnc = 0
    word_matches = self.getBNCTuples(self.text)
    if (len(word_matches) > 0):
        is_bnc = 1
        print  >> sys.stderr, 'BNC text detected.'
    else:
        word_matches = self.nonword.split(self.text)
    if (not is_bnc):
        j = (len(word_matches) - 1)
        while (j >= 0):
            w = word_matches[j]
            s_end_match = self.sentence_end.search(w)
            if s_end_match:
                word_matches[j] = w[:(len(w) - len(s_end_match.group(1)))]
                word_matches.insert((j + 1), s_end_match.group(1))
                break
            j = (j - 1)
    i = 0
    tagged_list = [self.DUMMY, self.DUMMY]
    tagged_list_bnc = [self.DUMMY, self.DUMMY]
    while (i < len(word_matches)):
        next_token = None
        tags = None
        if is_bnc:
            (tag, word) = word_matches[i]
            if ((i + 1) < len(word_matches)):
                (next_token, foo) = word_matches[(i + 1)]
            word = self.normalise(word)
            tags = self.splitBNCTag(tag)
        else:
            word = word_matches[i]
            if ((i + 1) < len(word_matches)):
                next_token = word_matches[(i + 1)]
        if (textlanguage == 'en'):
            if ((i + 2) < len(word_matches)):
                tuple_word = ('%s %s' % (word, word_matches[(i + 2)]))
                if data_table.has_key(tuple_word):
                    word = tuple_word
                    i = (i + 2)
        if ((len(word) >= 1) and (word[(-1)] == '.')):
            word = word[0:(-1)]
            r = Text.tagWord(self, word, data_table)
            tagged_list.extend(r)
            word = '.'
        r = Text.tagWord(self, word, data_table)
        tagged_list.extend(r)
        if is_bnc:
            for el in r:
                tagged_list_bnc.append((el[0], tags))
        i = (i + 1)
    tagged_list.append(self.DUMMY)
    tagged_list.append(self.DUMMY)
    prev_word = None
    next_word = None
    i = 0
    for tag_tuples in tagged_list:
        prev_word = self.getPrevWord(i, tagged_list)
        next_word = self.getNextWord(i, tagged_list)
        if (tag_tuples and tag_tuples[1]):
            self.applyConstraints(prev_word, tag_tuples[0], next_word, tag_tuples[2])
        i = (i + 1)
    result_tuple_list = self.selectTagsByContext(tagged_list, seqs_table_followed_by, seqs_table_follows, tagged_list_bnc, is_bnc, data_table)
    i = 0
    for tag_triple in result_tuple_list:
        triple = self.applyTagRules(tag_triple[0], tag_triple[1], tag_triple[2])
        if triple:
            result_tuple_list[i] = triple
        if self.sentence_end.search(tag_triple[0]):
            result_tuple_list[i] = (tag_triple[0], None, None)
        i = (i + 1)
    return result_tuple_list
