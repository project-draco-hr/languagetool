{
  CgRule rule=(CgRule)ruleObject;
  type=rule.type.name();
  if (rule.line > 500) {
    System.out.println();
  }
  List<String> ltRule=new ArrayList<String>();
  String cgRuleString=lines[rule.line];
  ltRule.add("<!-- " + cgRuleString + " -->");
  ArrayList<Token> tokensList=new ArrayList<Token>();
  ArrayList<ArrayList<Token>> outerList=new ArrayList<ArrayList<Token>>();
  ArrayList<Token[]> processedLists=new ArrayList<Token[]>();
  CgSet targetSet=expandSetSets(grammar.getSet(rule.target));
  Token target=new Token(targetSet,false,0,false,false,new CgSet(),false,0,false);
  if (!isOrCompatible(target)) {
    System.err.println("Target for rule on line " + rule.line + " cannot be represented as one LT rule. Rewrite");
    return new ArrayList<String>();
  }
  tokensList.add(target);
  ArrayList<CgContextualTest> sortedTestsHeads=new ArrayList<CgContextualTest>();
  for (  CgContextualTest test : rule.test_heads) {
    if (test.isParentTest()) {
      sortedTestsHeads.add(test);
    }
 else {
      sortedTestsHeads.add(0,test);
    }
  }
  for (  CgContextualTest test : sortedTestsHeads) {
    if (test.isNormalTest()) {
      Token testToken=getTokenFromNormalTest(test);
      tokensList.add(testToken);
    }
 else     if (test.isParentTest()) {
      if (!outerList.isEmpty()) {
        System.err.println("Can't have two parent tests in one test on line " + rule.line + "\nTry splitting it up.");
        System.exit(1);
      }
      for (      int testInt : test.ors) {
        ArrayList<Token> newTokenList=copyTokenList(tokensList);
        CgContextualTest childTest=rule.test_map.get(testInt);
        if (childTest.isNormalTest()) {
          Token childTestToken=getTokenFromNormalTest(childTest);
          newTokenList.add(childTestToken);
        }
 else         if (childTest.isLinkedTest()) {
          ArrayList<CgContextualTest> linkedTests=new ArrayList<CgContextualTest>();
          CgContextualTest curTest=childTest;
          while (curTest.next != 0) {
            linkedTests.add(curTest);
            curTest=rule.test_map.get(curTest.next);
          }
          linkedTests.add(curTest);
          Token headLinkedToken=getLinkedTokens(linkedTests);
          newTokenList.add(headLinkedToken);
        }
        outerList.add(newTokenList);
      }
    }
 else     if (test.isLinkedTest()) {
      ArrayList<CgContextualTest> linkedTests=new ArrayList<CgContextualTest>();
      CgContextualTest curTest=test;
      while (curTest.next != 0) {
        linkedTests.add(curTest);
        curTest=rule.test_map.get(curTest.next);
      }
      linkedTests.add(curTest);
      Token headLinkedToken=getLinkedTokens(linkedTests);
      tokensList.add(headLinkedToken);
    }
  }
  if (outerList.isEmpty()) {
    outerList.add(tokensList);
  }
  for (int i=0; i < outerList.size(); i++) {
    Token[] tokens=outerList.get(i).toArray(new Token[outerList.get(i).size()]);
    if (negativeBackwardBarrierScan(tokens)) {
      ArrayList<List<Token>> split=splitNegativeBackwardBarrierScan(tokens);
      outerList.remove(i);
      for (      List<Token> splitList : split) {
        outerList.add(i,new ArrayList<Token>(splitList));
        i++;
      }
    }
  }
  for (int i=0; i < outerList.size(); i++) {
    Token[] tokens=outerList.get(i).toArray(new Token[outerList.get(i).size()]);
    Arrays.sort(tokens);
    tokens=addGapTokens(tokens);
    if (skipSafe(tokens)) {
      tokens=addSkipTokens(tokens);
      tokens=resolveLinkedTokens(tokens);
      if (!singleRuleCompatible(tokens)) {
        ArrayList<List<Token>> singleRuleCompatibleTokens=splitForSingleRule(tokens);
        for (        List<Token> srctl : singleRuleCompatibleTokens) {
          Token[] srcta=srctl.toArray(new Token[srctl.size()]);
          processedLists.add(srcta);
        }
      }
 else {
        processedLists.add(tokens);
      }
    }
 else {
      ArrayList<List<Token>> splitTokenLists=getSkipSafeTokens(tokens);
      for (int j=0; j < splitTokenLists.size(); j++) {
        Token[] indSplitTokenList=splitTokenLists.get(j).toArray(new Token[splitTokenLists.get(j).size()]);
        indSplitTokenList=addSkipTokens(indSplitTokenList);
        indSplitTokenList=resolveLinkedTokens(indSplitTokenList);
        Arrays.sort(indSplitTokenList);
        indSplitTokenList=addGapTokens(indSplitTokenList);
        if (!singleRuleCompatible(indSplitTokenList)) {
          ArrayList<List<Token>> singleRuleCompatibleTokens=splitForSingleRule(indSplitTokenList);
          for (          List<Token> srctl : singleRuleCompatibleTokens) {
            Token[] srcta=srctl.toArray(new Token[srctl.size()]);
            processedLists.add(srcta);
          }
        }
 else {
          processedLists.add(indSplitTokenList);
        }
      }
    }
  }
  if (processedLists.size() == 1) {
    Token[] tokens=processedLists.get(0);
    List<String> ltRule2=getRuleByType(targetSet,tokens,rule,id,name,type);
    ltRule.addAll(ltRule2);
  }
 else {
    ltRule.add("<rulegroup name=\"" + generateName(ruleObject) + "\">");
    for (    Token[] tokens : processedLists) {
      List<String> ltRule2=getRuleByType(targetSet,tokens,rule,null,null,type);
      ltRule.addAll(ltRule2);
    }
    ltRule.add("</rulegroup>");
  }
  return ltRule;
}
