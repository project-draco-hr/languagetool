{
  final List<RuleMatch> ruleMatches=new ArrayList<>();
  final AnalyzedTokenReadings[] tokens=text.getTokensWithoutWhitespace();
  boolean repetition=false;
  final TreeSet<String> inflectedWords=new TreeSet<>();
  String prevLemma;
  int curToken=0;
  for (int i=1; i < tokens.length; i++) {
    final String token=tokens[i].getToken();
    boolean isWord=true;
    boolean hasLemma=true;
    if (token.length() < 2) {
      isWord=false;
    }
    for (    AnalyzedToken analyzedToken : tokens[i]) {
      final String posTag=analyzedToken.getPOSTag();
      if (posTag != null) {
        if (StringTools.isEmpty(posTag)) {
          isWord=false;
          break;
        }
        final String lemma=analyzedToken.getLemma();
        if (lemma == null) {
          hasLemma=false;
          break;
        }
        if (getExcludedWordsPattern().contains(lemma)) {
          isWord=false;
          break;
        }
        final Matcher m2=getExcludedPos().matcher(posTag);
        if (m2.matches()) {
          isWord=false;
          break;
        }
      }
 else {
        hasLemma=false;
      }
    }
    final Matcher m1=getExcludedNonWordsPattern().matcher(tokens[i].getToken());
    if (isWord && m1.matches()) {
      isWord=false;
    }
    prevLemma="";
    if (isWord) {
      boolean notSentEnd=false;
      for (      AnalyzedToken analyzedToken : tokens[i]) {
        final String pos=analyzedToken.getPOSTag();
        if (pos != null) {
          notSentEnd|=JLanguageTool.SENTENCE_END_TAGNAME.equals(pos);
        }
        if (hasLemma) {
          final String curLemma=analyzedToken.getLemma();
          if (!prevLemma.equals(curLemma) && !notSentEnd) {
            if (inflectedWords.contains(curLemma) && curToken != i) {
              repetition=true;
            }
 else {
              inflectedWords.add(analyzedToken.getLemma());
              curToken=i;
            }
          }
          prevLemma=curLemma;
        }
 else {
          if (inflectedWords.contains(tokens[i].getToken()) && !notSentEnd) {
            repetition=true;
          }
 else {
            inflectedWords.add(tokens[i].getToken());
          }
        }
      }
    }
    if (repetition) {
      final int pos=tokens[i].getStartPos();
      final RuleMatch ruleMatch=new RuleMatch(this,pos,pos + token.length(),getMessage(),getShortMessage());
      ruleMatches.add(ruleMatch);
      repetition=false;
    }
  }
  return toRuleMatchArray(ruleMatches);
}
