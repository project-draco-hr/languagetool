{
  sentenceCount=0;
  final List<String> sentences;
  if (tokenizeText) {
    sentences=sentenceTokenize(text);
  }
 else {
    sentences=new ArrayList<String>();
    sentences.add(text);
  }
  final List<RuleMatch> ruleMatches=new ArrayList<RuleMatch>();
  final List<Rule> allRules=getAllRules();
  printIfVerbose(allRules.size() + " rules activated for language " + language);
  int tokenCount=0;
  int lineCount=0;
  int columnCount=1;
  unknownWords=new HashSet<String>();
  for (  final String sentence : sentences) {
    sentenceCount++;
    AnalyzedSentence analyzedText=getAnalyzedSentence(sentence);
    rememberUnknownWords(analyzedText);
    if (sentenceCount == sentences.size()) {
      final AnalyzedTokenReadings[] anTokens=analyzedText.getTokens();
      anTokens[anTokens.length - 1].setParaEnd();
      analyzedText=new AnalyzedSentence(anTokens);
    }
    final List<RuleMatch> sentenceMatches=new ArrayList<RuleMatch>();
    printIfVerbose(analyzedText.toString());
    for (    final Rule rule : allRules) {
      if (disabledRules.contains(rule.getId()) || (rule.isDefaultOff() && !enabledRules.contains(rule.getId()))) {
        continue;
      }
      if (disabledCategories.contains(rule.getCategory().getName())) {
        continue;
      }
switch (paraMode) {
case ONLYNONPARA:
{
          if (rule.isParagraphBackTrack()) {
            continue;
          }
          break;
        }
case ONLYPARA:
{
        if (!rule.isParagraphBackTrack()) {
          continue;
        }
        break;
      }
case NORMAL:
default :
  }
  final RuleMatch[] thisMatches=rule.match(analyzedText);
  for (  final RuleMatch element1 : thisMatches) {
    final RuleMatch thisMatch=new RuleMatch(element1.getRule(),element1.getFromPos() + tokenCount,element1.getToPos() + tokenCount,element1.getMessage(),element1.getShortMessage());
    thisMatch.setSuggestedReplacements(element1.getSuggestedReplacements());
    final String sentencePartToError=sentence.substring(0,element1.getFromPos());
    final String sentencePartToEndOfError=sentence.substring(0,element1.getToPos());
    final int lastLineBreakPos=sentencePartToError.lastIndexOf('\n');
    final int column;
    final int endColumn;
    if (lastLineBreakPos == -1) {
      column=sentencePartToError.length() + columnCount;
    }
 else {
      column=sentencePartToError.length() - lastLineBreakPos;
    }
    final int lastLineBreakPosInError=sentencePartToEndOfError.lastIndexOf('\n');
    if (lastLineBreakPosInError == -1) {
      endColumn=sentencePartToEndOfError.length() + columnCount + 1;
    }
 else {
      endColumn=sentencePartToEndOfError.length() - lastLineBreakPos;
    }
    final int lineBreaksToError=countLineBreaks(sentencePartToError);
    final int lineBreaksToEndOfError=countLineBreaks(sentencePartToEndOfError);
    thisMatch.setLine(lineCount + lineBreaksToError);
    thisMatch.setEndLine(lineCount + lineBreaksToEndOfError);
    thisMatch.setColumn(column);
    thisMatch.setEndColumn(endColumn);
    thisMatch.setOffset(element1.getFromPos() + tokenCount);
    sentenceMatches.add(thisMatch);
    if (rule.isParagraphBackTrack()) {
      rule.addRuleMatch(thisMatch);
    }
  }
}
Collections.sort(sentenceMatches);
ruleMatches.addAll(sentenceMatches);
tokenCount+=sentence.length();
lineCount+=countLineBreaks(sentence);
final int lineBreakPos=sentence.indexOf('\n');
if (lineBreakPos == -1) {
  columnCount+=sentence.length() - 1;
}
 else {
  if (lineBreakPos == 0) {
    columnCount=sentence.length();
    if (!language.getSentenceTokenizer().singleLineBreaksMarksPara()) {
      columnCount--;
    }
  }
 else {
    columnCount=1;
  }
}
}
if (!paraMode.equals(paragraphHandling.ONLYNONPARA)) {
for (final Rule rule : allRules) {
  if (rule.isParagraphBackTrack() && (rule.getMatches() != null)) {
    final List<RuleMatch> rm=rule.getMatches();
    for (    final RuleMatch r : rm) {
      if (rule.isInRemoved(r)) {
        ruleMatches.remove(r);
      }
    }
  }
}
}
return ruleMatches;
}
