{
  sentenceCount=0;
  final List<String> sentences=sentenceTokenize(text);
  final List<RuleMatch> ruleMatches=new ArrayList<RuleMatch>();
  final List<Rule> allRules=getAllRules();
  printIfVerbose(allRules.size() + " rules activated for language " + language);
  int tokenCount=0;
  int lineCount=0;
  int columnCount=0;
  unknownWords=new HashSet<String>();
  for (  final String sentence : sentences) {
    sentenceCount++;
    AnalyzedSentence analyzedText=getAnalyzedSentence(sentence);
    rememberUnknownWords(analyzedText);
    if (sentenceCount == sentences.size()) {
      final AnalyzedTokenReadings[] anTokens=analyzedText.getTokens();
      final AnalyzedToken paragraphEnd=new AnalyzedToken(anTokens[anTokens.length - 1].getToken(),PARAGRAPH_END_TAGNAME,anTokens[anTokens.length - 1].getAnalyzedToken(0).getLemma(),anTokens[anTokens.length - 1].getAnalyzedToken(0).getStartPos());
      anTokens[anTokens.length - 1].addReading(paragraphEnd);
      analyzedText=new AnalyzedSentence(anTokens);
    }
    final List<RuleMatch> sentenceMatches=new ArrayList<RuleMatch>();
    printIfVerbose(analyzedText.toString());
    for (    final Rule rule : allRules) {
      if (disabledRules.contains(rule.getId()) || (rule.isDefaultOff() && !enabledRules.contains(rule.getId()))) {
        continue;
      }
      if (disabledCategories.contains(rule.getCategory().getName())) {
        continue;
      }
      final RuleMatch[] thisMatches=rule.match(analyzedText);
      for (      final RuleMatch element1 : thisMatches) {
        final RuleMatch thisMatch=new RuleMatch(element1.getRule(),element1.getFromPos() + tokenCount,element1.getToPos() + tokenCount,element1.getMessage(),element1.getShortMessage());
        thisMatch.setSuggestedReplacements(element1.getSuggestedReplacements());
        final String sentencePartToError=sentence.substring(0,element1.getFromPos());
        final String sentencePartToEndOfError=sentence.substring(0,element1.getToPos());
        final int lastLineBreakPos=sentencePartToError.lastIndexOf('\n');
        int column=-1;
        int endColumn=-1;
        if (lastLineBreakPos == -1) {
          column=sentencePartToError.length() + columnCount;
        }
 else {
          column=sentencePartToError.length() - lastLineBreakPos - 1;
        }
        final int lastLineBreakPosInError=sentencePartToEndOfError.lastIndexOf('\n');
        if (lastLineBreakPosInError == -1) {
          endColumn=sentencePartToEndOfError.length() + columnCount + 1;
        }
 else {
          endColumn=sentencePartToEndOfError.length() - lastLineBreakPos;
        }
        final int lineBreaksToError=countLineBreaks(sentencePartToError);
        final int lineBreaksToEndOfError=countLineBreaks(sentencePartToEndOfError);
        thisMatch.setLine(lineCount + lineBreaksToError);
        thisMatch.setEndLine(lineCount + lineBreaksToEndOfError);
        thisMatch.setColumn(column);
        thisMatch.setEndColumn(endColumn);
        thisMatch.setOffset(element1.getFromPos() + tokenCount);
        sentenceMatches.add(thisMatch);
        if (rule.isParagraphBackTrack()) {
          rule.addRuleMatch(thisMatch);
        }
      }
    }
    Collections.sort(sentenceMatches);
    ruleMatches.addAll(sentenceMatches);
    tokenCount+=sentence.length();
    lineCount+=countLineBreaks(sentence);
    final int linebreakPos=sentence.indexOf('\n');
    if (linebreakPos == -1) {
      columnCount+=sentence.length();
    }
 else {
      columnCount=sentence.length() - linebreakPos - 1;
    }
  }
  for (  final Rule rule : allRules) {
    if (rule.isParagraphBackTrack() && (rule.getMatches() != null)) {
      final List<RuleMatch> rm=rule.getMatches();
      for (      final RuleMatch r : rm) {
        if (rule.isInRemoved(r)) {
          ruleMatches.remove(r);
        }
      }
    }
  }
  return ruleMatches;
}
