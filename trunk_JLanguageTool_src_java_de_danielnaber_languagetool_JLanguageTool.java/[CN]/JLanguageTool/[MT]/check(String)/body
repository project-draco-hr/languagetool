{
  sentenceCount=0;
  List<String> sentences=sentenceTokenizer.tokenize(text);
  List<RuleMatch> ruleMatches=new ArrayList<RuleMatch>();
  List<Rule> allRules=getAllRules();
  printIfVerbose(allRules.size() + " rules activated for language " + language);
  int tokenCount=0;
  int lineCount=0;
  int columnCount=0;
  for (Iterator<String> iter=sentences.iterator(); iter.hasNext(); ) {
    String sentence=iter.next();
    sentenceCount++;
    AnalyzedSentence analyzedText=getAnalyzedSentence(sentence);
    if (sentenceCount == sentences.size()) {
      AnalyzedTokenReadings[] anTokens=analyzedText.getTokens();
      AnalyzedToken paragraphEnd=new AnalyzedToken(anTokens[anTokens.length - 1].getToken(),PARAGRAPH_END_TAGNAME,anTokens[anTokens.length - 1].getAnalyzedToken(0).getLemma());
      anTokens[anTokens.length - 1].addReading(paragraphEnd);
      analyzedText=new AnalyzedSentence(anTokens);
    }
    List<RuleMatch> sentenceMatches=new ArrayList<RuleMatch>();
    printIfVerbose(analyzedText.toString());
    for (Iterator<Rule> iterator=allRules.iterator(); iterator.hasNext(); ) {
      Rule rule=iterator.next();
      if (disabledRules.contains(rule.getId()))       continue;
      RuleMatch[] thisMatches=rule.match(analyzedText);
      for (int i=0; i < thisMatches.length; i++) {
        RuleMatch thisMatch=new RuleMatch(thisMatches[i].getRule(),thisMatches[i].getFromPos() + tokenCount,thisMatches[i].getToPos() + tokenCount,thisMatches[i].getMessage());
        thisMatch.setSuggestedReplacements(thisMatches[i].getSuggestedReplacements());
        String sentencePartToError=sentence.substring(0,thisMatches[i].getFromPos());
        String sentencePartToEndOfError=sentence.substring(0,thisMatches[i].getToPos());
        int lastLineBreakPos=sentencePartToError.lastIndexOf("\n");
        int column=-1;
        int endColumn=-1;
        if (lastLineBreakPos == -1) {
          column=sentencePartToError.length() + columnCount;
        }
 else {
          column=sentencePartToError.length() - lastLineBreakPos - 1;
        }
        int lastLineBreakPosInError=sentencePartToEndOfError.lastIndexOf("\n");
        if (lastLineBreakPosInError == -1) {
          endColumn=sentencePartToEndOfError.length() + columnCount + 1;
        }
 else {
          endColumn=sentencePartToEndOfError.length() - lastLineBreakPos;
        }
        int lineBreaksToError=countLineBreaks(sentencePartToError);
        int lineBreaksToEndOfError=countLineBreaks(sentencePartToEndOfError);
        thisMatch.setLine(lineCount + lineBreaksToError);
        thisMatch.setEndLine(lineCount + lineBreaksToEndOfError);
        thisMatch.setColumn(column);
        thisMatch.setEndColumn(endColumn);
        thisMatch.setOffset(thisMatches[i].getFromPos() + tokenCount);
        sentenceMatches.add(thisMatch);
        if (rule.isParagraphBackTrack()) {
          rule.addRuleMatch(thisMatch);
        }
      }
    }
    Collections.sort(sentenceMatches);
    ruleMatches.addAll(sentenceMatches);
    tokenCount+=sentence.length();
    lineCount+=countLineBreaks(sentence);
    int linebreakPos=sentence.indexOf("\n");
    if (linebreakPos == -1) {
      columnCount+=sentence.length();
    }
 else {
      columnCount=sentence.length() - linebreakPos - 1;
    }
  }
  for (  Rule rule : allRules) {
    if (rule.isParagraphBackTrack()) {
      if (rule.getMatches() != null) {
        List<RuleMatch> rm=rule.getMatches();
        for (        RuleMatch r : rm) {
          if (rule.isInRemoved(r)) {
            ruleMatches.remove(r);
          }
        }
      }
    }
  }
  return ruleMatches;
}
