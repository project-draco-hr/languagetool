{
  final AnalyzedTokenReadings[] whTokens=whiteTokens.clone();
  int correctedStPos=0;
  if (startPositionCorrection > 0) {
    for (int l=0; l <= startPositionCorrection; l++) {
      correctedStPos+=tokenPositions[l];
    }
    correctedStPos--;
  }
  final int fromPos=text.getOriginalPosition(firstMatchToken + correctedStPos);
  final int numRead=whTokens[fromPos].getReadingsLength();
  final boolean spaceBefore=whTokens[fromPos].isWhitespaceBefore();
  boolean filtered=false;
switch (disAction) {
case UNIFY:
    if (unifiedTokens != null) {
      if (unifiedTokens.length == matchingTokens - startPositionCorrection + endPositionCorrection) {
        if (whTokens[text.getOriginalPosition(firstMatchToken + correctedStPos + unifiedTokens.length - 1)].isSentEnd()) {
          unifiedTokens[unifiedTokens.length - 1].setSentEnd();
        }
        for (int i=0; i < unifiedTokens.length; i++) {
          final int position=text.getOriginalPosition(firstMatchToken + correctedStPos + i);
          unifiedTokens[i].setStartPos(whTokens[position].getStartPos());
          final String prevValue=whTokens[position].toString();
          final String prevAnot=whTokens[position].getHistoricalAnnotations();
          whTokens[position]=unifiedTokens[i];
          annotateChange(whTokens[position],prevValue,prevAnot);
        }
      }
    }
  break;
case REMOVE:
if (newTokenReadings != null) {
  if (newTokenReadings.length == matchingTokens - startPositionCorrection + endPositionCorrection) {
    for (int i=0; i < newTokenReadings.length; i++) {
      final int position=text.getOriginalPosition(firstMatchToken + correctedStPos + i);
      final String prevValue=whTokens[position].toString();
      final String prevAnot=whTokens[position].getHistoricalAnnotations();
      whTokens[position].removeReading(newTokenReadings[i]);
      annotateChange(whTokens[position],prevValue,prevAnot);
    }
  }
}
break;
case ADD:
if (newTokenReadings != null) {
if (newTokenReadings.length == matchingTokens - startPositionCorrection + endPositionCorrection) {
String lemma;
String token;
for (int i=0; i < newTokenReadings.length; i++) {
  final int position=text.getOriginalPosition(firstMatchToken + correctedStPos + i);
  if ("".equals(newTokenReadings[i].getToken())) {
    token=whTokens[position].getToken();
  }
 else {
    token=newTokenReadings[i].getToken();
  }
  if (newTokenReadings[i].getLemma() == null) {
    lemma=token;
  }
 else {
    lemma=newTokenReadings[i].getLemma();
  }
  final AnalyzedToken newTok=new AnalyzedToken(token,newTokenReadings[i].getPOSTag(),lemma);
  final String prevValue=whTokens[position].toString();
  final String prevAnot=whTokens[position].getHistoricalAnnotations();
  whTokens[position].addReading(newTok);
  annotateChange(whTokens[position],prevValue,prevAnot);
}
}
}
break;
case FILTERALL:
for (int i=0; i < matchingTokens - startPositionCorrection + endPositionCorrection; i++) {
final int position=text.getOriginalPosition(firstMatchToken + correctedStPos + i);
final Element myEl=patternElements.get(i + startPositionCorrection);
final Match tmpMatchToken=new Match(myEl.getPOStag(),null,true,myEl.getPOStag(),null,Match.CaseConversion.NONE,false,false,Match.IncludeRange.NONE);
tmpMatchToken.setToken(whTokens[position]);
final String prevValue=whTokens[position].toString();
final String prevAnot=whTokens[position].getHistoricalAnnotations();
whTokens[position]=tmpMatchToken.filterReadings();
annotateChange(whTokens[position],prevValue,prevAnot);
}
break;
case IMMUNIZE:
for (int i=0; i < matchingTokens - startPositionCorrection + endPositionCorrection; i++) {
whTokens[text.getOriginalPosition(firstMatchToken + correctedStPos + i)].immunize();
}
break;
case FILTER:
if (matchElement == null) {
final Match tmpMatchToken=new Match(disambiguatedPOS,null,true,disambiguatedPOS,null,Match.CaseConversion.NONE,false,false,Match.IncludeRange.NONE);
tmpMatchToken.setToken(whTokens[fromPos]);
final String prevValue=whTokens[fromPos].toString();
final String prevAnot=whTokens[fromPos].getHistoricalAnnotations();
whTokens[fromPos]=tmpMatchToken.filterReadings();
annotateChange(whTokens[fromPos],prevValue,prevAnot);
filtered=true;
}
case REPLACE:
default :
if (!filtered) {
if (newTokenReadings != null && newTokenReadings.length > 0) {
if (newTokenReadings.length == matchingTokens - startPositionCorrection + endPositionCorrection) {
String lemma;
String token;
for (int i=0; i < newTokenReadings.length; i++) {
final int position=text.getOriginalPosition(firstMatchToken + correctedStPos + i);
if ("".equals(newTokenReadings[i].getToken())) {
token=whTokens[position].getToken();
}
 else {
token=newTokenReadings[i].getToken();
}
if (newTokenReadings[i].getLemma() == null) {
lemma=token;
}
 else {
lemma=newTokenReadings[i].getLemma();
}
final AnalyzedTokenReadings toReplace=new AnalyzedTokenReadings(new AnalyzedToken(token,newTokenReadings[i].getPOSTag(),lemma),whTokens[fromPos].getStartPos());
whTokens[position]=replaceTokens(whTokens[position],toReplace);
}
}
}
 else if (matchElement == null) {
String lemma="";
for (int l=0; l < numRead; l++) {
if (whTokens[fromPos].getAnalyzedToken(l).getPOSTag() != null && (whTokens[fromPos].getAnalyzedToken(l).getPOSTag().equals(disambiguatedPOS) && (whTokens[fromPos].getAnalyzedToken(l).getLemma() != null))) {
lemma=whTokens[fromPos].getAnalyzedToken(l).getLemma();
}
}
if (StringTools.isEmpty(lemma)) {
lemma=whTokens[fromPos].getAnalyzedToken(0).getLemma();
}
final AnalyzedTokenReadings toReplace=new AnalyzedTokenReadings(new AnalyzedToken(whTokens[fromPos].getToken(),disambiguatedPOS,lemma),whTokens[fromPos].getStartPos());
whTokens[fromPos]=replaceTokens(whTokens[fromPos],toReplace);
}
 else {
matchElement.setToken(whTokens[fromPos]);
final String prevValue=whTokens[fromPos].toString();
final String prevAnot=whTokens[fromPos].getHistoricalAnnotations();
whTokens[fromPos]=matchElement.filterReadings();
whTokens[fromPos].setWhitespaceBefore(spaceBefore);
annotateChange(whTokens[fromPos],prevValue,prevAnot);
}
}
}
return whTokens;
}
