{
  final List<RuleMatch> ruleMatches=new ArrayList<RuleMatch>();
  final AnalyzedTokenReadings[] tokens=text.getTokens();
  String prevToken="";
  String prevPrevToken="";
  boolean prevWhite=false;
  int pos=0;
  int prevLen=0;
  for (int i=0; i < tokens.length; i++) {
    final String token=tokens[i].getToken();
    final boolean isWhite=tokens[i].isWhitespace() || tokens[i].isFieldCode();
    pos+=token.length();
    String msg=null;
    int fixFromLen=0;
    int fixToLen=0;
    String suggestionText=null;
    if (isWhite && isLeftBracket(prevToken)) {
      msg=messages.getString("no_space_after");
      suggestionText=prevToken;
      fixToLen=1;
    }
 else     if (i > 0 && !prevWhite && isLeftBracket(token)) {
      msg=messages.getString("missing_space_before");
      suggestionText=" " + token;
      fixFromLen=prevToken.length();
      fixToLen=1;
    }
 else     if (!isWhite && prevToken.equals(",") && isNotQuoteOrHyphen(token)&& containsNoNumber(prevPrevToken)&& containsNoNumber(token)&& !",".equals(prevPrevToken)) {
      msg=messages.getString("missing_space_after_comma");
      suggestionText=", ";
    }
 else     if (prevWhite) {
      if (isRightBracket(token)) {
        msg=messages.getString("no_space_before");
        suggestionText=token;
        fixToLen=1;
      }
 else       if (token.equals(",")) {
        msg=messages.getString("space_after_comma");
        suggestionText=",";
        fixToLen=1;
        if (i + 1 < tokens.length && ",".equals(tokens[i + 1].getToken())) {
          msg=null;
        }
      }
 else       if (token.equals(".")) {
        msg=messages.getString("no_space_before_dot");
        suggestionText=".";
        fixToLen=1;
        if (i + 1 < tokens.length && isNumberOrDot(tokens[i + 1].getToken())) {
          msg=null;
        }
      }
    }
    if (msg != null) {
      final int fromPos=tokens[i - 1].getStartPos() + fixFromLen;
      final int toPos=tokens[i - 1].getStartPos() + fixToLen + prevLen;
      final RuleMatch ruleMatch=new RuleMatch(this,fromPos,toPos,msg);
      ruleMatch.setSuggestedReplacement(suggestionText);
      ruleMatches.add(ruleMatch);
    }
    prevPrevToken=prevToken;
    prevToken=token;
    prevWhite=isWhite && !tokens[i].isFieldCode();
    prevLen=tokens[i].getToken().length();
  }
  return toRuleMatchArray(ruleMatches);
}
