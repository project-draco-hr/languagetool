{
  List<RuleMatch> ruleMatches=new ArrayList<RuleMatch>();
  AnalyzedTokenReadings[] tokens=text.getTokens();
  String prevToken="";
  int pos=0;
  for (int i=0; i < tokens.length; i++) {
    String token=tokens[i].getToken();
    pos+=token.length();
    String msg=null;
    int fixPos=0;
    int fixLen=0;
    String suggestionText=null;
    if (token.trim().equals("") && prevToken.trim().equals("(")) {
      msg=messages.getString("no_space_after");
      suggestionText="(";
      fixLen=1;
    }
 else     if (token.trim().equals(")") && prevToken.trim().equals("")) {
      msg=messages.getString("no_space_before");
      suggestionText=")";
      fixLen=1;
    }
 else     if (prevToken.trim().equals(",") && !token.trim().equals("") && !token.equals("'")&& !token.equals("\"")&& !token.matches(".*\\d.*")) {
      msg=messages.getString("missing_space_after_comma");
      suggestionText=", ";
    }
 else     if (token.trim().equals(",") && prevToken.trim().equals("")) {
      msg=messages.getString("space_after_comma");
      suggestionText=",";
      fixLen=1;
    }
    if (msg != null) {
      int fromPos=tokens[i - 1].getStartPos() + fixPos;
      int toPos=tokens[i - 1].getStartPos() + fixPos + fixLen+ prevToken.length();
      RuleMatch ruleMatch=new RuleMatch(this,fromPos,toPos,msg);
      if (suggestionText != null)       ruleMatch.setSuggestedReplacement(suggestionText);
      ruleMatches.add(ruleMatch);
    }
    prevToken=token;
  }
  return toRuleMatchArray(ruleMatches);
}
