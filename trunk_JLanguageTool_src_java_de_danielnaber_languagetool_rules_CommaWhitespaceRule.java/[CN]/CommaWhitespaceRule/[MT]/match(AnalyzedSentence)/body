{
  final List<RuleMatch> ruleMatches=new ArrayList<RuleMatch>();
  final AnalyzedTokenReadings[] tokens=text.getTokens();
  String prevToken="";
  boolean prevWhite=false;
  int pos=0;
  int prevLen=0;
  for (int i=0; i < tokens.length; i++) {
    final String token=tokens[i].getToken();
    final boolean isWhite=tokens[i].isWhitespace() || tokens[i].isFieldCode();
    pos+=token.length();
    String msg=null;
    int fixLen=0;
    String suggestionText=null;
    if (isWhite && prevToken.equals("(")) {
      msg=messages.getString("no_space_after");
      suggestionText="(";
      fixLen=1;
    }
 else     if (token.equals(")") && prevWhite) {
      msg=messages.getString("no_space_before");
      suggestionText=")";
      fixLen=1;
    }
 else     if (prevToken.equals(",") && !isWhite && !token.equals("'")&& !token.equals("&quot")&& !token.equals("???")&& !token.equals("???")&& !token.equals("\"")&& !token.equals("???")&& !token.matches(".*\\d.*")&& !token.equals("-")) {
      msg=messages.getString("missing_space_after_comma");
      suggestionText=", ";
    }
 else     if (token.equals(",") && prevWhite) {
      msg=messages.getString("space_after_comma");
      suggestionText=",";
      fixLen=1;
    }
 else     if (token.equals(".") && prevWhite) {
      msg=messages.getString("no_space_before_dot");
      suggestionText=".";
      fixLen=1;
      if (i + 1 < tokens.length && tokens[i + 1].getToken().matches("\\d.*|\\.")) {
        msg=null;
      }
    }
    if (msg != null) {
      final int fromPos=tokens[i - 1].getStartPos();
      final int toPos=tokens[i - 1].getStartPos() + fixLen + prevLen;
      final RuleMatch ruleMatch=new RuleMatch(this,fromPos,toPos,msg);
      if (suggestionText != null) {
        ruleMatch.setSuggestedReplacement(suggestionText);
      }
      ruleMatches.add(ruleMatch);
    }
    prevToken=token;
    prevWhite=isWhite && !tokens[i].isFieldCode();
    prevLen=tokens[i].getToken().length();
  }
  return toRuleMatchArray(ruleMatches);
}
