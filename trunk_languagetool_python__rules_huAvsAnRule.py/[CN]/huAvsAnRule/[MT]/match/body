def match(self, tagged_words, chunks, position_fix=0, line_fix=0, column_fix=0):
    matches = []
    text_length = 0
    i = 0
    while 1:
        if (i >= (len(tagged_words) - 2)):
            break
        org_word = tagged_words[i][0]
        org_word_next = tagged_words[(i + 2)][0]
        if (org_word.lower() == 'a'):
            err = 0
            if (org_word_next.lower() in self.requires_an):
                err = 1
            elif ((len(org_word_next) > 0) and (org_word_next[0].lower() in ('a', 'e', 'i', 'o', 'u', u'\xe1', u'\xe9', u'\xf6', u'\xfc', u'\xed', u'\xfb', u'\xf5', u'\xfa')) and (not (org_word_next.lower() in self.requires_a)) and (not self.IsRoman(org_word_next.upper()))):
                err = 1
            if err:
                matches.append(Rules.RuleMatch(self.rule_id, (text_length + position_fix), ((text_length + len(org_word)) + position_fix), ('Hasznaljon <em>az-t a</em> helyett ' + 'ha a kovetkezo szo maganhangzoval kezdodik'), org_word))
        text_length = (text_length + len(org_word))
        i = (i + 1)
    return matches
