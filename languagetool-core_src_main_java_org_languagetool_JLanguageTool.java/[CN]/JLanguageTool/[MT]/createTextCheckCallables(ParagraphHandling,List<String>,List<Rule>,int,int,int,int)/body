{
  final int totalRules=allRules.size();
  final int chunkSize=totalRules / threads;
  int firstItem=0;
  final List<Callable<List<RuleMatch>>> callables=new ArrayList<>();
  final List<AnalyzedSentence> analyzedSentences=new ArrayList<>();
  int j=0;
  for (  final String sentence : sentences) {
    AnalyzedSentence analyzedSentence=getAnalyzedSentence(sentence);
    rememberUnknownWords(analyzedSentence);
    if (++j == sentences.size()) {
      final AnalyzedTokenReadings[] anTokens=analyzedSentence.getTokens();
      anTokens[anTokens.length - 1].setParaEnd();
      analyzedSentence=new AnalyzedSentence(anTokens);
    }
    analyzedSentences.add(analyzedSentence);
    printIfVerbose(analyzedSentence.toString());
    printIfVerbose(analyzedSentence.getAnnotations());
  }
  for (int i=0; i < threads; i++) {
    final List<Rule> subRules;
    if (i == threads - 1) {
      subRules=allRules.subList(firstItem,totalRules);
    }
 else {
      subRules=allRules.subList(firstItem,firstItem + chunkSize);
    }
    callables.add(new TextCheckCallable(subRules,sentences,analyzedSentences,paraMode,charCount,lineCount,columnCount));
    firstItem=firstItem + chunkSize;
  }
  return callables;
}
