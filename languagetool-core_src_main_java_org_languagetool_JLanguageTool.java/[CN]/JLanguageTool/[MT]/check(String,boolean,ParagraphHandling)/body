{
  sentenceCount=0;
  final List<String> sentences;
  if (tokenizeText) {
    sentences=sentenceTokenize(text);
  }
 else {
    sentences=new ArrayList<String>();
    sentences.add(text);
  }
  final List<RuleMatch> ruleMatches=new ArrayList<RuleMatch>();
  final List<Rule> allRules=getAllRules();
  printIfVerbose(allRules.size() + " rules activated for language " + language);
  int charCount=0;
  int lineCount=0;
  int columnCount=1;
  unknownWords=new HashSet<String>();
  for (  final String sentence : sentences) {
    sentenceCount++;
    AnalyzedSentence analyzedSentence=getAnalyzedSentence(sentence);
    rememberUnknownWords(analyzedSentence);
    if (sentenceCount == sentences.size()) {
      final AnalyzedTokenReadings[] anTokens=analyzedSentence.getTokens();
      anTokens[anTokens.length - 1].setParaEnd();
      analyzedSentence=new AnalyzedSentence(anTokens);
    }
    printIfVerbose(analyzedSentence.toString());
    printIfVerbose(analyzedSentence.getAnnotations());
    final List<RuleMatch> sentenceMatches=checkAnalyzedSentence(paraMode,allRules,charCount,lineCount,columnCount,sentence,analyzedSentence);
    Collections.sort(sentenceMatches);
    ruleMatches.addAll(sentenceMatches);
    charCount+=sentence.length();
    lineCount+=countLineBreaks(sentence);
    final int lineBreakPos=sentence.lastIndexOf('\n');
    if (lineBreakPos == -1) {
      columnCount+=sentence.length();
    }
 else {
      if (lineBreakPos == 0) {
        columnCount=sentence.length();
        if (!language.getSentenceTokenizer().singleLineBreaksMarksPara()) {
          columnCount--;
        }
      }
 else {
        columnCount=sentence.length() - lineBreakPos;
      }
    }
  }
  if (!ruleMatches.isEmpty() && !paraMode.equals(ParagraphHandling.ONLYNONPARA)) {
    for (    final Rule rule : allRules) {
      if (rule.isParagraphBackTrack() && (rule.getMatches() != null)) {
        final List<RuleMatch> rm=rule.getMatches();
        for (        final RuleMatch r : rm) {
          if (rule.isInRemoved(r)) {
            ruleMatches.remove(r);
          }
        }
      }
    }
  }
  return ruleMatches;
}
