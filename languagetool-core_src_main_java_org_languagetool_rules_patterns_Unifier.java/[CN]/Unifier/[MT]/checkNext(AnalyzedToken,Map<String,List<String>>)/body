{
  boolean anyFeatUnified=false;
  List<String> types;
  final List<Boolean> tokenFeaturesFound=new ArrayList<>(tmpFeaturesFound);
  if (allFeatsIn) {
    for (int i=0; i < tokCnt; i++) {
      boolean allFeatsUnified=true;
      for (      Map.Entry<String,List<String>> feat : uFeatures.entrySet()) {
        boolean featUnified=false;
        types=feat.getValue();
        if (types == null || types.isEmpty()) {
          types=equivalenceFeatures.get(feat.getKey());
        }
        for (        final String typeName : types) {
          if (equivalencesMatched.get(i).containsKey(feat.getKey()) && equivalencesMatched.get(i).get(feat.getKey()).contains(typeName)) {
            final Element testElem=equivalenceTypes.get(new EquivalenceTypeLocator(feat.getKey(),typeName));
            boolean matched=testElem.isMatched(aToken);
            featUnified=featUnified || matched;
            if (matched) {
              if (!equivalencesToBeKept.containsKey(feat.getKey())) {
                final Set<String> typeSet=new HashSet<>();
                typeSet.add(typeName);
                equivalencesToBeKept.put(feat.getKey(),typeSet);
              }
 else {
                equivalencesToBeKept.get(feat.getKey()).add(typeName);
              }
            }
          }
        }
        allFeatsUnified&=featUnified;
      }
      tokenFeaturesFound.set(i,tokenFeaturesFound.get(i) || allFeatsUnified);
      anyFeatUnified=anyFeatUnified || allFeatsUnified;
    }
    if (anyFeatUnified) {
      if (tokSequence.size() == readingsCounter) {
        tokSequence.add(new AnalyzedTokenReadings(aToken,0));
      }
 else {
        if (readingsCounter < tokSequence.size()) {
          tokSequence.get(readingsCounter).addReading(aToken);
        }
 else {
          anyFeatUnified=false;
        }
      }
      tmpFeaturesFound=tokenFeaturesFound;
    }
  }
  return anyFeatUnified;
}
