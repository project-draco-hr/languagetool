{
  final List<RuleMatch> ruleMatches=new ArrayList<RuleMatch>();
  final AnalyzedTokenReadings[] tokens=text.getTokensWithoutWhitespace();
  RuleMatch prevRuleMatch=null;
  final Queue<AnalyzedTokenReadings> prevTokens=new ArrayBlockingQueue<AnalyzedTokenReadings>(MAX_TERMS);
  for (int i=0; i < tokens.length + MAX_TERMS - 1; i++) {
    AnalyzedTokenReadings token=null;
    if (i >= tokens.length) {
      token=new AnalyzedTokenReadings(new AnalyzedToken("","",null),prevTokens.peek().getStartPos());
    }
 else {
      token=tokens[i];
    }
    if (i == 0) {
      addToQueue(token,prevTokens);
      continue;
    }
    final StringBuilder sb=new StringBuilder();
    int j=0;
    AnalyzedTokenReadings firstMatchToken=null;
    final List<String> stringsToCheck=new ArrayList<String>();
    final List<String> origStringsToCheck=new ArrayList<String>();
    final Map<String,AnalyzedTokenReadings> stringToToken=new HashMap<String,AnalyzedTokenReadings>();
    for (    AnalyzedTokenReadings atr : prevTokens) {
      if (j == 0) {
        firstMatchToken=atr;
      }
      sb.append(' ');
      sb.append(atr.getToken());
      if (j >= 1) {
        final String stringToCheck=normalize(sb.toString());
        stringsToCheck.add(stringToCheck);
        origStringsToCheck.add(sb.toString().trim());
        if (!stringToToken.containsKey(stringToCheck))         stringToToken.put(stringToCheck,atr);
      }
      j++;
    }
    for (int k=stringsToCheck.size() - 1; k >= 0; k--) {
      final String stringToCheck=stringsToCheck.get(k);
      final String origStringToCheck=origStringsToCheck.get(k);
      if (incorrectCompounds.contains(stringToCheck)) {
        final AnalyzedTokenReadings atr=stringToToken.get(stringToCheck);
        String msg=null;
        final List<String> replacement=new ArrayList<String>();
        if (!noDashSuggestion.contains(stringToCheck)) {
          replacement.add(origStringToCheck.replace(' ','-'));
          msg=withHyphenMessage;
        }
        if (!hasAllUppercaseParts(origStringToCheck) && countParts(stringToCheck) <= getMaxUnHyphenatedWordCount() && !onlyDashSuggestion.contains(stringToCheck)) {
          replacement.add(mergeCompound(origStringToCheck));
          msg=withoutHyphenMessage;
        }
        final String[] parts=stringToCheck.split(" ");
        if (parts.length > 0 && parts[0].length() == 1) {
          replacement.clear();
          replacement.add(origStringToCheck.replace(' ','-'));
          msg=withHyphenMessage;
        }
 else         if (replacement.isEmpty() || replacement.size() == 2) {
          msg=withOrWithoutHyphenMessage;
        }
        final RuleMatch ruleMatch=new RuleMatch(this,firstMatchToken.getStartPos(),atr.getStartPos() + atr.getToken().length(),msg,shortDesc);
        if (prevRuleMatch != null && prevRuleMatch.getFromPos() == ruleMatch.getFromPos()) {
          prevRuleMatch=ruleMatch;
          break;
        }
        prevRuleMatch=ruleMatch;
        ruleMatch.setSuggestedReplacements(replacement);
        ruleMatches.add(ruleMatch);
        break;
      }
    }
    addToQueue(token,prevTokens);
  }
  return toRuleMatchArray(ruleMatches);
}
