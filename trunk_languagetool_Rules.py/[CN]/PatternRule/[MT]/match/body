def match(self, tagged_words, position_fix):
    'Check if there are rules that match the tagged_words. Returns a list\n\t\tof RuleMatch objects.'
    matches = []
    ct = 0
    tagged_words_copy = tagged_words
    for word_tag_tuple in tagged_words_copy:
        i = ct
        p = 0
        expected_token = None
        found = None
        match = 1
        first_match = ct
        while match:
            try:
                if ((not tagged_words_copy[i][1]) and (tagged_words_copy[i][2] != 'SENT_START') and (tagged_words_copy[i][2] != 'SENT_END')):
                    i = (i + 1)
                    ct = (ct + 1)
                    continue
            except IndexError:
                break
            try:
                expected_token = self.tokens[p]
            except IndexError:
                break
            if (tagged_words_copy[i][2] == 'SENT_START'):
                found = 'SENT_START'
            elif (tagged_words_copy[i][2] == 'SENT_END'):
                found = 'SENT_END'
            elif expected_token.is_word:
                try:
                    found = tagged_words_copy[i][1]
                except:
                    break
            else:
                try:
                    found = tagged_words_copy[i][2]
                except:
                    break
            if (not found):
                break
            case_switch = re.IGNORECASE
            if self.case_sensitive:
                case_switch = 0
            match = re.compile((expected_token.token + '$'), case_switch).match(found)
            if expected_token.negation:
                if (not match):
                    match = 1
                else:
                    match = None
            i = (i + 1)
            p = (p + 1)
        if (match and (p == len(self.tokens))):
            ct_tmp = 0
            list_match_from = 0
            list_match_to = 0
            from_pos = 0
            to_pos = 0
            for tagged_word in tagged_words_copy:
                if (ct_tmp < (first_match + self.marker_position)):
                    from_pos = (from_pos + len(tagged_word[0]))
                    list_match_from = (ct_tmp + 1)
                if (ct_tmp < (ct + self.marker_position)):
                    to_pos = (to_pos + len(tagged_word[0]))
                    list_match_to = (ct_tmp + 1)
                ct_tmp = (ct_tmp + 1)
            match = RuleMatch(self.rule_id, (from_pos + position_fix), (to_pos + position_fix), list_match_from, list_match_to, self.message)
            matches.append(match)
        ct = (ct + 1)
    return matches
