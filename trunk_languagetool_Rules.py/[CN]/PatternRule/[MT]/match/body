def match(self, tagged_words, position_fix):
    'Check if there are rules that match the tagged_words. Returns a list\n\t\tof RuleMatch objects.'
    matches = []
    ct = 0
    tagged_words_copy = tagged_words
    last_match = None
    for word_tag_tuple in tagged_words_copy:
        i = ct
        p = 0
        expected_token = None
        found = None
        match = 1
        first_match = None
        while match:
            try:
                if (not self.isRealWord(tagged_words_copy, i)):
                    i = (i + 1)
                    ct = (ct + 1)
                    continue
                elif (not first_match):
                    first_match = ct
            except IndexError:
                break
            try:
                expected_token = self.tokens[p]
            except IndexError:
                break
            expected_token_str = expected_token.token
            if (tagged_words_copy[i][2] == 'SENT_START'):
                found = 'SENT_START'
            elif (tagged_words_copy[i][2] == 'SENT_END'):
                found = 'SENT_END'
            elif expected_token.is_word:
                try:
                    found = tagged_words_copy[i][1].strip()
                except:
                    break
            else:
                try:
                    found = tagged_words_copy[i][2]
                except:
                    break
            if (not found):
                break
            case_switch = re.IGNORECASE
            if self.case_sensitive:
                case_switch = 0
            match = re.compile(('%s$' % expected_token_str), case_switch).match(found)
            if expected_token.negation:
                if (not match):
                    match = 1
                else:
                    match = None
            i = (i + 1)
            p = (p + 1)
        if (match and (p == len(self.tokens))):
            (first_match, from_pos, to_pos) = self.listPosToAbsPos(tagged_words_copy, first_match)
            to_upper = 0
            if (tagged_words_copy[first_match][0][0] in string.uppercase):
                to_upper = 1
            l = first_match
            lcount = 1
            msg = self.message
            while (lcount <= len(self.tokens)):
                if self.isRealWord(tagged_words_copy, l):
                    msg = msg.replace(('\\%d' % lcount), tagged_words_copy[l][0])
                    lcount = (lcount + 1)
                l = (l + 1)
            match = RuleMatch(self.rule_id, (from_pos + position_fix), (to_pos + position_fix), msg, to_upper)
            matches.append(match)
        ct = (ct + 1)
    return matches
