def match(self, tagged_words, chunks=None, position_fix=0):
    'Check if there are rules that match the tagged_words. Returns a list\n\t\tof RuleMatch objects.'
    matches = []
    ct = 0
    tagged_words_copy = tagged_words
    last_match = None
    for word_tag_tuple in tagged_words_copy:
        i = ct
        p = 0
        expected_token = None
        found = None
        match = 1
        first_match = None
        chunk_corr = 0
        chunk_len = 0
        while match:
            try:
                if (not self.isRealWord(tagged_words_copy, i)):
                    i = (i + 1)
                    ct = (ct + 1)
                    continue
                elif (not first_match):
                    first_match = ct
            except IndexError:
                break
            try:
                expected_token = self.tokens[p]
            except IndexError:
                break
            expected_token_str = expected_token.token
            if (tagged_words_copy[i][2] == 'SENT_START'):
                found = 'SENT_START'
            elif (tagged_words_copy[i][2] == 'SENT_END'):
                found = 'SENT_END'
            elif expected_token.is_word:
                try:
                    found = tagged_words_copy[i][1].strip()
                except:
                    break
            elif expected_token.is_chunk:
                found = None
                for (from_pos, to_pos, chunk_name) in chunks:
                    if ((i >= from_pos) and (i <= to_pos)):
                        found = chunk_name
                        i = (i + (to_pos - from_pos))
                        chunk_corr = (chunk_corr + (to_pos - from_pos))
                        chunk_len = (chunk_len + 1)
                        break
            else:
                try:
                    found = tagged_words_copy[i][2]
                except:
                    break
            if (not found):
                break
            case_switch = re.IGNORECASE
            if self.case_sensitive:
                case_switch = 0
            if expected_token.simple_token:
                if case_switch:
                    match = (expected_token_str.lower() == found.lower())
                else:
                    match = (expected_token_str == found)
            else:
                match = re.compile(('%s$' % expected_token_str), case_switch).match(found)
            if expected_token.negation:
                if (not match):
                    match = 1
                else:
                    match = None
            i = (i + 1)
            p = (p + 1)
        if (match and (p == len(self.tokens))):
            (first_match, from_pos, to_pos) = self.listPosToAbsPos(tagged_words_copy, first_match, 0)
            to_pos = (to_pos + chunk_corr)
            l = first_match
            lcount = 1
            msg = self.message
            while ((lcount <= len(self.tokens)) and (l < len(tagged_words_copy))):
                if self.isRealWord(tagged_words_copy, l):
                    msg = msg.replace(('\\%d' % lcount), tagged_words_copy[l][0])
                    lcount = (lcount + 1)
                l = (l + 1)
            first_match_word = tagged_words_copy[first_match][0]
            match = RuleMatch(self.rule_id, (from_pos + position_fix), (to_pos + position_fix), msg, first_match_word)
            matches.append(match)
        elif (p == len(self.tokens)):
            break
        ct = (ct + 1)
    return matches
