{
  final AnalyzedTokenReadings[] tokens=text.getTokensWithoutWhitespace();
  final AnalyzedTokenReadings[] whTokens=text.getTokens();
  final int[] tokenPositions=new int[tokens.length + 1];
  int tokenPos=0;
  int prevSkipNext=0;
  int skipNext=0;
  int matchPos=0;
  int skipShift=0;
  int skipShiftTotal=0;
  int firstMatchToken=-1;
  final int patternSize=patternElements.size();
  Element elem=null, prevElement=null;
  final boolean startWithSentStart=patternElements.get(0).isSentStart();
  boolean inUnification=false;
  boolean uniMatched=false;
  AnalyzedTokenReadings[] unifiedTokens=null;
  for (int i=0; i < tokens.length; i++) {
    boolean allElementsMatch=true;
    if (patternSize + i > tokens.length) {
      allElementsMatch=false;
      break;
    }
    if (startWithSentStart && i > 0) {
      allElementsMatch=false;
      break;
    }
    int matchingTokens=0;
    for (int k=0; (k < patternSize); k++) {
      if (elem != null) {
        prevElement=elem;
      }
      elem=patternElements.get(k);
      skipNext=elem.getSkipNext();
      final int nextPos=tokenPos + k + skipShiftTotal;
      if (nextPos >= tokens.length) {
        allElementsMatch=false;
        break;
      }
      boolean skipMatch=false, thisMatched=false, prevMatched=false;
      boolean exceptionMatched=false;
      if (prevSkipNext + nextPos >= tokens.length || prevSkipNext < 0) {
        prevSkipNext=tokens.length - (nextPos + 1);
      }
      for (int m=nextPos; m <= nextPos + prevSkipNext; m++) {
        boolean matched=false;
        final int numberOfReadings=tokens[m].getReadingsLength();
        for (int l=0; l < numberOfReadings; l++) {
          final AnalyzedToken matchToken=tokens[m].getAnalyzedToken(l);
          if (prevSkipNext > 0 && prevElement != null && prevElement.isMatchedByScopeNextException(matchToken)) {
            exceptionMatched=true;
            prevMatched=true;
          }
          if (elem.isReferenceElement() && (firstMatchToken + elem.getMatch().getTokenRef() < tokens.length)) {
            elem.compile(tokens[firstMatchToken + elem.getMatch().getTokenRef()],language.getSynthesizer());
          }
          if (elem.hasAndGroup()) {
            for (            final Element andElement : elem.getAndGroup()) {
              if (andElement.isReferenceElement() && (firstMatchToken + andElement.getMatch().getTokenRef() < tokens.length)) {
                andElement.compile(tokens[firstMatchToken + andElement.getMatch().getTokenRef()],language.getSynthesizer());
              }
            }
            if (l == 0) {
              elem.setupAndGroup();
            }
          }
          thisMatched|=elem.isMatchedCompletely(matchToken);
          if (thisMatched && elem.isUnified()) {
            if (inUnification) {
              uniMatched=uniMatched || language.getUnifier().isSatisfied(matchToken,elem.getUniFeature(),elem.getUniType());
              if (l + 1 == numberOfReadings) {
                thisMatched&=uniMatched;
                language.getUnifier().startNextToken();
                if (uniMatched) {
                  unifiedTokens=language.getUnifier().getUnifiedTokens();
                }
              }
            }
 else {
              if (elem.getUniNegation()) {
                language.getUnifier().setNegation(true);
              }
              thisMatched|=language.getUnifier().isSatisfied(matchToken,elem.getUniFeature(),elem.getUniType());
              if (l + 1 == numberOfReadings) {
                inUnification=true;
                language.getUnifier().startUnify();
                uniMatched=false;
              }
            }
          }
          if (!elem.isUnified()) {
            inUnification=false;
            uniMatched=false;
            language.getUnifier().reset();
          }
          if (l + 1 == numberOfReadings && elem.hasAndGroup()) {
            thisMatched&=elem.checkAndGroup(thisMatched);
          }
          exceptionMatched|=elem.isExceptionMatchedCompletely(matchToken);
          if (elem.hasPreviousException() && m > 0) {
            final int numReadings=tokens[m - 1].getReadingsLength();
            for (int p=0; p < numReadings; p++) {
              final AnalyzedToken matchExceptionToken=tokens[m - 1].getAnalyzedToken(p);
              exceptionMatched|=elem.isMatchedByScopePreviousException(matchExceptionToken);
            }
          }
          if (thisMatched || exceptionMatched) {
            matched=true;
            matchPos=m;
            skipShift=matchPos - nextPos;
            tokenPositions[matchingTokens]=skipShift + 1;
          }
 else {
            matched|=false;
          }
          skipMatch=(skipMatch || matched) && !exceptionMatched;
        }
        if (!(thisMatched || prevMatched)) {
          exceptionMatched=false;
          skipMatch=false;
        }
        if (skipMatch) {
          break;
        }
      }
      allElementsMatch=skipMatch;
      if (skipMatch) {
        prevSkipNext=skipNext;
        matchingTokens++;
        if (firstMatchToken == -1) {
          firstMatchToken=matchPos;
        }
        skipShiftTotal+=skipShift;
      }
 else {
        prevSkipNext=0;
        skipShiftTotal=0;
        break;
      }
    }
    tokenPos++;
    if (allElementsMatch) {
      int correctedStPos=0;
      if (startPositionCorrection > 0) {
        for (int l=0; l <= startPositionCorrection; l++) {
          correctedStPos+=tokenPositions[l];
        }
        correctedStPos--;
      }
      int correctedEndPos=0;
      if (endPositionCorrection < 0) {
        int l=0;
        while (l > endPositionCorrection) {
          correctedEndPos-=tokenPositions[matchingTokens + l - 1];
          l--;
        }
      }
      final int fromPos=text.getOriginalPosition(firstMatchToken + correctedStPos);
      final int numRead=whTokens[fromPos].getReadingsLength();
      boolean filtered=false;
switch (disAction) {
case UNIFY:
{
          if (unifiedTokens != null) {
            if (unifiedTokens.length == matchingTokens - startPositionCorrection + endPositionCorrection) {
              for (i=0; i < unifiedTokens.length; i++) {
                whTokens[text.getOriginalPosition(firstMatchToken + correctedStPos + i)]=unifiedTokens[i];
              }
              unifiedTokens=null;
            }
          }
          break;
        }
case REMOVE:
{
        if (newTokenReadings != null) {
          if (newTokenReadings.length == matchingTokens - startPositionCorrection + endPositionCorrection) {
            for (i=0; i < newTokenReadings.length; i++) {
              whTokens[text.getOriginalPosition(firstMatchToken + correctedStPos + i)].removeReading(newTokenReadings[i]);
            }
          }
        }
        break;
      }
case ADD:
{
      if (newTokenReadings != null) {
        if (newTokenReadings.length == matchingTokens - startPositionCorrection + endPositionCorrection) {
          for (i=0; i < newTokenReadings.length; i++) {
            whTokens[text.getOriginalPosition(firstMatchToken + correctedStPos + i)].addReading(newTokenReadings[i]);
          }
        }
      }
      break;
    }
case FILTER:
{
    if (matchToken == null) {
      Match tmpMatchToken=new Match(disambiguatedPOS,null,true,disambiguatedPOS,null,Match.CaseConversion.NONE,false);
      tmpMatchToken.setToken(whTokens[fromPos]);
      whTokens[fromPos]=tmpMatchToken.filterReadings(whTokens[fromPos]);
      filtered=true;
    }
  }
case REPLACE:
default :
{
  if (!filtered) {
    if (matchToken == null) {
      String lemma="";
      for (int l=0; l < numRead; l++) {
        if (whTokens[fromPos].getAnalyzedToken(l).getPOSTag() != null && (whTokens[fromPos].getAnalyzedToken(l).getPOSTag().equals(disambiguatedPOS) && (whTokens[fromPos].getAnalyzedToken(l).getLemma() != null))) {
          lemma=whTokens[fromPos].getAnalyzedToken(l).getLemma();
        }
      }
      if (StringTools.isEmpty(lemma)) {
        lemma=whTokens[fromPos].getAnalyzedToken(0).getLemma();
      }
      final AnalyzedTokenReadings toReplace=new AnalyzedTokenReadings(new AnalyzedToken(whTokens[fromPos].getToken(),disambiguatedPOS,lemma,whTokens[fromPos].getStartPos()));
      whTokens[fromPos]=toReplace;
    }
 else {
      matchToken.setToken(whTokens[fromPos]);
      whTokens[fromPos]=matchToken.filterReadings(whTokens[fromPos]);
    }
  }
}
}
}
firstMatchToken=-1;
skipShiftTotal=0;
language.getUnifier().reset();
inUnification=false;
uniMatched=false;
}
return new AnalyzedSentence(whTokens);
}
