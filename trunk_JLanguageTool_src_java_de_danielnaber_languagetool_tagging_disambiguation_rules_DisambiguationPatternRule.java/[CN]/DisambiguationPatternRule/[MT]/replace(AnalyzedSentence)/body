{
  final AnalyzedTokenReadings[] tokens=text.getTokensWithoutWhitespace();
  AnalyzedTokenReadings[] whTokens=text.getTokens();
  final int[] tokenPositions=new int[tokens.length + 1];
  final int patternSize=patternElements.size();
  Element elem=null;
  final boolean startWithSentStart=patternElements.get(0).isSentStart();
  for (int i=0; i < tokens.length; i++) {
    boolean allElementsMatch=true;
    if (patternSize + i > tokens.length || startWithSentStart && i > 0) {
      allElementsMatch=false;
      break;
    }
    unifiedTokens=null;
    int matchingTokens=0;
    int skipShiftTotal=0;
    int firstMatchToken=-1;
    int prevSkipNext=0;
    language.getUnifier().reset();
    for (int k=0; k < patternSize; k++) {
      final Element prevElement=elem;
      elem=patternElements.get(k);
      setupRef(firstMatchToken,elem,tokens);
      final int skipNext=elem.getSkipNext();
      final int nextPos=i + k + skipShiftTotal;
      if (nextPos >= tokens.length) {
        allElementsMatch=false;
        break;
      }
      prevMatched=false;
      if (prevSkipNext + nextPos >= tokens.length || prevSkipNext < 0) {
        prevSkipNext=tokens.length - (nextPos + 1);
      }
      for (int m=nextPos; m <= nextPos + prevSkipNext; m++) {
        allElementsMatch=testAllReadings(tokens,elem,prevElement,m,firstMatchToken,prevSkipNext);
        if (allElementsMatch) {
          final int skipShift=m - nextPos;
          tokenPositions[matchingTokens]=skipShift + 1;
          prevSkipNext=skipNext;
          matchingTokens++;
          skipShiftTotal+=skipShift;
          if (firstMatchToken == -1) {
            firstMatchToken=m;
          }
          break;
        }
      }
      if (!allElementsMatch) {
        break;
      }
    }
    if (allElementsMatch) {
      whTokens=executeAction(text,whTokens,unifiedTokens,firstMatchToken,matchingTokens,tokenPositions);
    }
  }
  return new AnalyzedSentence(whTokens,text.getWhPositions());
}
