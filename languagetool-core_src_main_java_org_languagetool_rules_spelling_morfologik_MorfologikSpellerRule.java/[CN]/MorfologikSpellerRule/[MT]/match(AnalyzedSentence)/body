{
  final List<RuleMatch> ruleMatches=new ArrayList<>();
  final AnalyzedTokenReadings[] tokens=sentence.getTokensWithoutWhitespace();
  if (speller1 == null) {
    String binaryDict=null;
    String plainTextDict=null;
    if (JLanguageTool.getDataBroker().resourceExists(getFileName())) {
      binaryDict=getFileName();
    }
    if (JLanguageTool.getDataBroker().resourceExists(getSpellingFileName())) {
      plainTextDict=getSpellingFileName();
    }
    if (binaryDict != null) {
      if (plainTextDict != null) {
        speller1=new MorfologikMultiSpeller(binaryDict,plainTextDict,1);
        speller2=new MorfologikMultiSpeller(binaryDict,plainTextDict,2);
        setConvertsCase(speller1.convertsCase());
      }
 else {
        throw new RuntimeException("Could not find ignore spell file in path: " + getSpellingFileName());
      }
    }
 else {
      return toRuleMatchArray(ruleMatches);
    }
  }
  int idx=-1;
  for (  AnalyzedTokenReadings token : tokens) {
    idx++;
    if (token.isSentenceStart()) {
      continue;
    }
    if (isUrl(token.getToken())) {
      continue;
    }
    if (ignoreToken(tokens,idx) || token.isImmunized() || token.isIgnoredBySpeller()) {
      continue;
    }
    if (ignoreTaggedWords && token.isTagged()) {
      continue;
    }
    final String word=token.getAnalyzedToken(0).getToken();
    if (tokenizingPattern() == null) {
      ruleMatches.addAll(getRuleMatches(word,token.getStartPos()));
    }
 else {
      int index=0;
      final Matcher m=tokenizingPattern().matcher(word);
      while (m.find()) {
        final String match=word.subSequence(index,m.start()).toString();
        ruleMatches.addAll(getRuleMatches(match,token.getStartPos() + index));
        index=m.end();
      }
      if (index == 0) {
        ruleMatches.addAll(getRuleMatches(word,token.getStartPos()));
      }
 else {
        ruleMatches.addAll(getRuleMatches(word.subSequence(index,word.length()).toString(),token.getStartPos() + index));
      }
    }
  }
  return toRuleMatchArray(ruleMatches);
}
