{
  final List<RuleMatch> ruleMatches=new ArrayList<>();
  final AnalyzedTokenReadings[] tokens=text.getTokens();
  boolean prevWhite=false;
  int prevLen=0;
  for (int i=0; i < tokens.length; i++) {
    final String token=tokens[i].getToken();
    final boolean isWhitespace=tokens[i].isWhitespace() || StringTools.isNonBreakingWhitespace(token) || tokens[i].isFieldCode();
    String msg=null;
    String suggestionText=null;
    if (prevWhite) {
      if (token.equals(":")) {
        msg=messages.getString("no_space_before_colon");
        suggestionText=":";
        if (i + 2 < tokens.length && tokens[i + 1].isWhitespace() && Character.isDigit(tokens[i + 2].getToken().charAt(0))) {
          msg=null;
        }
      }
 else       if (token.equals(";")) {
        msg=messages.getString("no_space_before_semicolon");
        suggestionText=";";
      }
 else       if (i > 1 && token.equals("%") && Character.isDigit(tokens[i - 2].getToken().charAt(0))) {
        msg=messages.getString("no_space_before_percentage");
        suggestionText="%";
      }
    }
    if (msg != null) {
      final int fromPos=tokens[i - 1].getStartPos();
      final int toPos=tokens[i - 1].getStartPos() + 1 + prevLen;
      final RuleMatch ruleMatch=new RuleMatch(this,fromPos,toPos,msg);
      ruleMatch.setSuggestedReplacement(suggestionText);
      ruleMatches.add(ruleMatch);
    }
    prevWhite=isWhitespace && !tokens[i].isFieldCode();
    prevLen=tokens[i].getToken().length();
  }
  return toRuleMatchArray(ruleMatches);
}
