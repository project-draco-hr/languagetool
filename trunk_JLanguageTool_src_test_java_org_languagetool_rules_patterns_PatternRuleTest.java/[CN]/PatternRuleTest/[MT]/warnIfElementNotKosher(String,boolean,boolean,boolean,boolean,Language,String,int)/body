{
  if (!isRegularExpression && PROBABLE_PATTERN.matcher(stringValue).find()) {
    System.err.println("The " + lang.toString() + " rule: "+ ruleId+ ", token ["+ tokenIndex+ "], contains "+ "\""+ stringValue+ "\" that is not marked as regular expression but probably is one.");
  }
  if (isRegularExpression && stringValue.isEmpty()) {
    System.err.println("The " + lang.toString() + " rule: "+ ruleId+ ", token ["+ tokenIndex+ "], contains an empty string "+ "\""+ stringValue+ "\" that is marked as regular expression.");
  }
 else   if (isRegularExpression && !PROBABLE_PATTERN.matcher(stringValue).find()) {
    System.err.println("The " + lang.toString() + " rule: "+ ruleId+ ", token ["+ tokenIndex+ "], contains "+ "\""+ stringValue+ "\" that is marked as regular expression but probably is not one.");
  }
  if (isNegated && stringValue.isEmpty()) {
    System.err.println("The " + lang.toString() + " rule: "+ ruleId+ ", token ["+ tokenIndex+ "], marked as negated but is "+ "empty so the negation is useless. Did you mix up "+ "negate=\"yes\" and negate_pos=\"yes\"?");
  }
  if (isInflected && stringValue.isEmpty()) {
    System.err.println("The " + lang.toString() + " rule: "+ ruleId+ ", token ["+ tokenIndex+ "], contains "+ "\""+ stringValue+ "\" that is marked as inflected but is empty, so the attribute is redundant.");
  }
  if (isRegularExpression && ".*".equals(stringValue)) {
    System.err.println("The " + lang.toString() + " rule: "+ ruleId+ ", token ["+ tokenIndex+ "], marked as regular expression contains "+ "regular expression \".*\" which is useless: "+ "(use an empty string without regexp=\"yes\" such as <token/>)");
  }
  if (isRegularExpression) {
    final Matcher matcher=CHAR_SET_PATTERN.matcher(stringValue);
    if (matcher.find()) {
      String s=matcher.group(2).replaceAll("\\\\p\\{[^}]*\\}","");
      if (s.indexOf('|') >= 0) {
        System.err.println("The " + lang.toString() + " rule: "+ ruleId+ ", token ["+ tokenIndex+ "], contains | (pipe) in "+ " regexp bracket expression ["+ matcher.group(2)+ "] which is unlikely to be correct.");
      }
      char[] sorted=s.toCharArray();
      java.util.Arrays.sort(sorted);
      for (int i=1; i < sorted.length; ++i) {
        char c=sorted[i];
        if ("&\\-|".indexOf(c) < 0 && sorted[i - 1] == c) {
          System.err.println("The " + lang.toString() + " rule: "+ ruleId+ ", token ["+ tokenIndex+ "], contains "+ " regexp part ["+ matcher.group(2)+ "] which contains duplicated char ["+ c+ "].");
          break;
        }
      }
    }
  }
  if (isRegularExpression && stringValue.contains("|")) {
    final Matcher matcher=EMPTY_DISJUNCTION.matcher(stringValue);
    if (matcher.find()) {
      System.err.println("The " + lang.toString() + " rule: "+ ruleId+ ", token ["+ tokenIndex+ "], contains empty "+ "disjunction | within "+ "\""+ stringValue+ "\".");
    }
    final String[] groups=stringValue.split("\\)");
    for (    final String group : groups) {
      final String[] alt=group.split("\\|");
      final Set<String> partSet=new HashSet<String>();
      final Set<String> partSetNoCase=new HashSet<String>();
      for (      String part : alt) {
        final String partNoCase=isCaseSensitive ? part : part.toLowerCase();
        if (partSetNoCase.contains(partNoCase)) {
          if (partSet.contains(part)) {
            System.err.println("The " + lang.toString() + " rule: "+ ruleId+ ", token ["+ tokenIndex+ "], contains "+ "duplicated disjunction part ("+ part+ ") within "+ "\""+ stringValue+ "\".");
          }
 else {
            System.err.println("The " + lang.toString() + " rule: "+ ruleId+ ", token ["+ tokenIndex+ "], contains duplicated "+ "non case sensitive disjunction part ("+ part+ ") within "+ "\""+ stringValue+ "\". Did you "+ "forget case_sensitive=\"yes\"?");
          }
        }
        partSetNoCase.add(partNoCase);
        partSet.add(part);
      }
    }
  }
}
