{
  final List<RuleMatch> ruleMatches=new ArrayList<>();
  final AnalyzedTokenReadings[] tokens=text.getTokens();
  boolean prevWhite=false;
  int prevLen=0;
  int prevPos=0;
  int i=1;
  while (i < tokens.length) {
    final boolean tokenIsTab=tokens[i].getToken().equals("\t");
    final boolean prevTokenIsLinebreak=tokens[i - 1].isLinebreak();
    if ((tokens[i].isWhitespace() || StringTools.isNonBreakingWhitespace(tokens[i].getToken())) && prevWhite && !tokenIsTab&& !prevTokenIsLinebreak) {
      final int pos=tokens[i - 1].getStartPos();
      while (i < tokens.length && (tokens[i].isWhitespace() || StringTools.isNonBreakingWhitespace(tokens[i].getToken()))) {
        prevLen+=tokens[i].getToken().length();
        i++;
      }
      final String message=messages.getString("whitespace_repetition");
      final RuleMatch ruleMatch=new RuleMatch(this,prevPos,pos + prevLen,message);
      ruleMatch.setSuggestedReplacement(" ");
      ruleMatches.add(ruleMatch);
    }
    if (i < tokens.length) {
      prevWhite=tokens[i].isWhitespace() || StringTools.isNonBreakingWhitespace(tokens[i].getToken());
      prevLen=tokens[i].getToken().length();
      prevPos=tokens[i].getStartPos();
      i++;
    }
  }
  return toRuleMatchArray(ruleMatches);
}
